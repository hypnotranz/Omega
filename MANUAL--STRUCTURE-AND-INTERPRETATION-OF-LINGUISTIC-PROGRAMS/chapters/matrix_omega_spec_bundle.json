{
  "meta": {
    "version": "0.1.0",
    "generated_at": "2026-01-31T22:34:32.223112+00:00",
    "assumptions": [
      "JSON is a carrier; CDTs are semantic types with invariants, operations, and tests.",
      "All semantic operations are Env-parameterized and treated as effectful (Kleisli) unless proven pure.",
      "Matrix URIs plus SnapshotRef provide stable addressing and evidence anchoring for provenance and replay.",
      "Budgets are enforced as first-class resources (tokens/calls/time) to prevent unbounded inference.",
      "Contracts are mandatory at effect boundaries; outputs failing schema/enum coercion are rejected."
    ],
    "glossary": [
      {
        "term": "Cognitive Data Type (CDT)",
        "definition": "A semantic value type with canonical representation, invariants, and operations; serializable to JSON but not reducible to JSON."
      },
      {
        "term": "Cognitive Primitive Operation (CPO)",
        "definition": "A minimal typed operation (often effectful) over CDTs, enforced by contracts, budgets, and provenance."
      },
      {
        "term": "Cognitive Algorithm (CA)",
        "definition": "A deterministic program skeleton that composes compute with CPOs, including cost/budget semantics and failure handling."
      },
      {
        "term": "Meaning Normal Form (MNF)",
        "definition": "Canonical normalization layer for semantic values enabling stable caching, equivalence, and contract enforcement."
      },
      {
        "term": "Matrix View",
        "definition": "A deterministic projection of an addressable artifact (e.g., ASTView, RelationalView) used as the substrate for inference and compute."
      }
    ]
  },
  "mnf": {
    "meaning_normal_form": {
      "types": [
        {
          "name": "Text",
          "json_shape": {
            "_type": "MNF.Text",
            "text": "...",
            "lang": "en"
          },
          "invariants": [
            "Unicode NFC",
            "explicit lang tag",
            "no hidden control chars"
          ]
        },
        {
          "name": "Label",
          "json_shape": {
            "_type": "MNF.Label",
            "value": "..."
          },
          "invariants": [
            "from controlled vocabulary or ontology"
          ]
        },
        {
          "name": "YesNo",
          "json_shape": {
            "_type": "MNF.YesNo",
            "value": "yes|no"
          },
          "invariants": [
            "value ∈ {yes,no}"
          ]
        },
        {
          "name": "Score",
          "json_shape": {
            "_type": "MNF.Score",
            "value": 0.0
          },
          "invariants": [
            "0.0 ≤ value ≤ 1.0"
          ]
        },
        {
          "name": "Span",
          "json_shape": {
            "_type": "MNF.Span",
            "uri": "matrix://...",
            "snapshot_id": "sha256:...",
            "start": 0,
            "end": 1
          },
          "invariants": [
            "start<end",
            "snapshot_id required"
          ]
        },
        {
          "name": "EvidenceSet",
          "json_shape": {
            "_type": "MNF.EvidenceSet",
            "items": [
              {
                "kind": "span",
                "ref": "..."
              }
            ]
          },
          "invariants": [
            "items are resolvable evidence refs"
          ]
        },
        {
          "name": "Policy",
          "json_shape": {
            "_type": "MNF.Policy",
            "rules": [
              {
                "id": "...",
                "effect": "allow|deny"
              }
            ]
          },
          "invariants": [
            "rules total-order by precedence"
          ]
        },
        {
          "name": "Plan",
          "json_shape": {
            "_type": "MNF.Plan",
            "ops": [
              {
                "op": "...",
                "contract": "..."
              }
            ]
          },
          "invariants": [
            "ops have contracts",
            "ops are budgeted"
          ]
        },
        {
          "name": "ProvenanceDAG",
          "json_shape": {
            "_type": "MNF.ProvenanceDAG",
            "nodes": [
              {
                "id": "n1"
              }
            ],
            "edges": [
              [
                "n0",
                "n1"
              ]
            ]
          },
          "invariants": [
            "acyclic",
            "node ids unique"
          ]
        },
        {
          "name": "RelationalView",
          "json_shape": {
            "_type": "MNF.RelationalView",
            "schema": {
              "columns": [
                {
                  "name": "id",
                  "type": "int"
                }
              ]
            },
            "rows": [
              [
                1
              ]
            ]
          },
          "invariants": [
            "rows conform to schema"
          ]
        },
        {
          "name": "ASTView",
          "json_shape": {
            "_type": "MNF.ASTView",
            "language": "ts",
            "root": {
              "kind": "Program"
            }
          },
          "invariants": [
            "tree is well-formed for language grammar"
          ]
        },
        {
          "name": "URI",
          "json_shape": {
            "_type": "MNF.URI",
            "value": "matrix://..."
          },
          "invariants": [
            "matches matrix URI grammar"
          ]
        },
        {
          "name": "SnapshotRef",
          "json_shape": {
            "_type": "MNF.SnapshotRef",
            "snapshot_id": "sha256:..."
          },
          "invariants": [
            "snapshot_id is content-addressed hash"
          ]
        }
      ],
      "normalization_rules": [
        "All semantic objects carry explicit _type tags and stable ids.",
        "All references to source artifacts are by (uri, snapshot_id, local ref) rather than raw copied text.",
        "All unordered sets are canonicalized (sorted) prior to hashing and caching.",
        "All enums are coerced to closed sets; out-of-vocabulary values are rejected, not guessed."
      ],
      "coercions": [
        {
          "from": "Text",
          "to": "YesNo",
          "method": "closed-enum coercion with rejection"
        },
        {
          "from": "Text",
          "to": "Label",
          "method": "ontology lookup + best-match with confidence threshold"
        },
        {
          "from": "Any",
          "to": "Span",
          "method": "require explicit uri+snapshot+offsets; never infer offsets"
        },
        {
          "from": "Any",
          "to": "RelationalView",
          "method": "deterministic parsing/ETL into schema+rows if possible"
        }
      ]
    }
  },
  "matrix": {
    "uri_scheme": {
      "grammar": "matrix://<realm>/<mount>/<path>(?<query>)(#<fragment>)",
      "examples": [
        "matrix://acme/project/src/auth.ts?view=ast",
        "matrix://acme/db/users?view=relational",
        "matrix://acme/docs/contract.pdf?view=clause",
        "matrix://home/thermostat?view=timeline"
      ]
    },
    "ports": [
      {
        "name": "StatePort",
        "commands": [
          "snapshot",
          "invalidate_cache"
        ],
        "events": [
          "state_changed",
          "cache_invalidated"
        ],
        "queries": [
          "get_state",
          "get_metadata"
        ]
      },
      {
        "name": "QueryPort",
        "commands": [],
        "events": [],
        "queries": [
          "query",
          "search",
          "capabilities"
        ]
      },
      {
        "name": "CommandPort",
        "commands": [
          "command",
          "apply_patch",
          "rollback"
        ],
        "events": [
          "command_accepted",
          "command_failed"
        ],
        "queries": [
          "get_status"
        ]
      },
      {
        "name": "EventPort",
        "commands": [
          "subscribe",
          "unsubscribe"
        ],
        "events": [
          "event"
        ],
        "queries": [
          "list_topics"
        ]
      },
      {
        "name": "ViewPort",
        "commands": [
          "view",
          "refresh_view"
        ],
        "events": [
          "view_ready",
          "view_stale"
        ],
        "queries": [
          "describe_views"
        ]
      }
    ],
    "views": [
      {
        "name": "RelationalView",
        "description": "Schema + rowset projection (tables/CSVs/spreadsheets/JSONL) with stable cell/row refs.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "schema": {
              "type": "object"
            },
            "rows": {
              "type": "array"
            }
          },
          "required": [
            "schema",
            "rows"
          ]
        },
        "operations": [
          "CPO.query",
          "CPO.extract",
          "CPO.summarize"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/db/<table>?view=relational",
          "matrix://<realm>/files/<name>.csv?view=relational"
        ]
      },
      {
        "name": "ASTView",
        "description": "Lossless syntax tree projection with stable node ids, spans, symbol links.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string"
            },
            "root": {
              "type": "object"
            }
          },
          "required": [
            "language",
            "root"
          ]
        },
        "operations": [
          "CPO.extract",
          "CPO.check_constraints",
          "CPO.generate_patch"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/project/<path>?view=ast"
        ]
      },
      {
        "name": "ClauseView",
        "description": "Document segmented into clauses with clause ids, spans, and deontic modality tags.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "clauses": {
              "type": "array"
            }
          },
          "required": [
            "clauses"
          ]
        },
        "operations": [
          "CPO.extract",
          "CPO.judge",
          "CPO.redact"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/docs/<file>.pdf?view=clause",
          "matrix://<realm>/docs/<file>.md?view=clause"
        ]
      },
      {
        "name": "TimelineView",
        "description": "Time-ordered event stream with stable event ids and timestamps.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "events": {
              "type": "array"
            }
          },
          "required": [
            "events"
          ]
        },
        "operations": [
          "CPO.resequence",
          "CPO.aggregate",
          "CPO.summarize"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/logs/<file>?view=timeline",
          "matrix://<realm>/ops/<service>?view=timeline"
        ]
      },
      {
        "name": "EvidenceView",
        "description": "Evidence envelope binding claims to SpanRef/RowRef/ClauseRef with provenance.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "evidence": {
              "type": "array"
            }
          },
          "required": [
            "evidence"
          ]
        },
        "operations": [
          "CPO.cite",
          "CPO.emit_provenance",
          "CPO.minimize_provenance"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/<any>?view=evidence"
        ]
      },
      {
        "name": "GraphView",
        "description": "Typed node/edge graph (dependencies, lineage, call graphs, constraint networks).",
        "contract_schema": {
          "type": "object",
          "properties": {
            "nodes": {
              "type": "array"
            },
            "edges": {
              "type": "array"
            }
          },
          "required": [
            "nodes",
            "edges"
          ]
        },
        "operations": [
          "CPO.aggregate",
          "CPO.check_constraints",
          "CPO.propagate_constraints"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/project?view=graph",
          "matrix://<realm>/db?view=lineage"
        ]
      },
      {
        "name": "StateMachineView",
        "description": "States/transitions projection with guards and invariants.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "states": {
              "type": "array"
            },
            "transitions": {
              "type": "array"
            }
          },
          "required": [
            "states",
            "transitions"
          ]
        },
        "operations": [
          "CPO.check_constraints",
          "CPO.judge"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/<artifact>?view=statemachine"
        ]
      },
      {
        "name": "APIView",
        "description": "Endpoint catalog with request/response schemas and auth/rate-limit metadata.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "endpoints": {
              "type": "array"
            }
          },
          "required": [
            "endpoints"
          ]
        },
        "operations": [
          "CPO.extract",
          "CPO.check_constraints",
          "CPO.plan"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/api?view=api"
        ]
      },
      {
        "name": "TraceView",
        "description": "Distributed tracing spans with causal links and service boundaries.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "spans": {
              "type": "array"
            }
          },
          "required": [
            "spans"
          ]
        },
        "operations": [
          "CPO.resequence",
          "CPO.aggregate",
          "CPO.summarize"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/traces/<trace_id>?view=trace"
        ]
      },
      {
        "name": "UIComponentView",
        "description": "UI component tree with action ports and stateful properties.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "tree": {
              "type": "object"
            }
          },
          "required": [
            "tree"
          ]
        },
        "operations": [
          "CPO.plan",
          "CPO.command",
          "CPO.check_constraints"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/app/ui/<root>?view=component-tree"
        ]
      },
      {
        "name": "DeviceView",
        "description": "Device capability + state projection for IoT endpoints.",
        "contract_schema": {
          "type": "object",
          "properties": {
            "state": {
              "type": "object"
            },
            "capabilities": {
              "type": "array"
            }
          },
          "required": [
            "state"
          ]
        },
        "operations": [
          "CPO.query",
          "CPO.command",
          "CPO.aggregate"
        ],
        "example_uri_patterns": [
          "matrix://<realm>/home/<device>?view=device"
        ]
      }
    ]
  },
  "cdt_catalog": [
    {
      "name": "CDT.Core.URI",
      "category_path": [
        "core",
        "uri"
      ],
      "description": "URI — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.URI",
        "data": {}
      },
      "canonical_lisp_shape": "(URI :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/uri"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-uri",
          "prompt": "Produce a canonical URI value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.URI"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.URI",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.CapabilitySet",
      "category_path": [
        "core",
        "capabilityset"
      ],
      "description": "CapabilitySet — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.CapabilitySet",
        "data": {}
      },
      "canonical_lisp_shape": "(CapabilitySet :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/capabilityset"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-capabilityset",
          "prompt": "Produce a canonical CapabilitySet value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.CapabilitySet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.CapabilitySet",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.SnapshotRef",
      "category_path": [
        "core",
        "snapshotref"
      ],
      "description": "SnapshotRef — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.SnapshotRef",
        "data": {}
      },
      "canonical_lisp_shape": "(SnapshotRef :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/snapshotref"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-snapshotref",
          "prompt": "Produce a canonical SnapshotRef value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SnapshotRef"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.SnapshotRef",
            "uri": "matrix://...",
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.ContentHash",
      "category_path": [
        "core",
        "contenthash"
      ],
      "description": "ContentHash — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.ContentHash",
        "data": {}
      },
      "canonical_lisp_shape": "(ContentHash :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/contenthash"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-contenthash",
          "prompt": "Produce a canonical ContentHash value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.ContentHash"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.ContentHash",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.SemanticKey",
      "category_path": [
        "core",
        "semantickey"
      ],
      "description": "SemanticKey — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.SemanticKey",
        "data": {}
      },
      "canonical_lisp_shape": "(SemanticKey :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/semantickey"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-semantickey",
          "prompt": "Produce a canonical SemanticKey value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SemanticKey"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.SemanticKey",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.CacheEntry",
      "category_path": [
        "core",
        "cacheentry"
      ],
      "description": "CacheEntry — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.CacheEntry",
        "data": {}
      },
      "canonical_lisp_shape": "(CacheEntry :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/cacheentry"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-cacheentry",
          "prompt": "Produce a canonical CacheEntry value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.CacheEntry"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.CacheEntry",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Budget",
      "category_path": [
        "core",
        "budget"
      ],
      "description": "Budget — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Budget",
        "data": {}
      },
      "canonical_lisp_shape": "(Budget :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/budget"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-budget",
          "prompt": "Produce a canonical Budget value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Budget"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Budget",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Env",
      "category_path": [
        "core",
        "env"
      ],
      "description": "Env — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Env",
        "data": {}
      },
      "canonical_lisp_shape": "(Env :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/env"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-env",
          "prompt": "Produce a canonical Env value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Env"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Env",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Policy",
      "category_path": [
        "core",
        "policy"
      ],
      "description": "Policy — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Policy",
        "data": {}
      },
      "canonical_lisp_shape": "(Policy :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/policy"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-policy",
          "prompt": "Produce a canonical Policy value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Policy"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Policy",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.SemanticContract",
      "category_path": [
        "core",
        "semanticcontract"
      ],
      "description": "SemanticContract — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.SemanticContract",
        "data": {}
      },
      "canonical_lisp_shape": "(SemanticContract :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/semanticcontract"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-semanticcontract",
          "prompt": "Produce a canonical SemanticContract value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SemanticContract"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.SemanticContract",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.EnumSpec",
      "category_path": [
        "core",
        "enumspec"
      ],
      "description": "EnumSpec — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.EnumSpec",
        "data": {}
      },
      "canonical_lisp_shape": "(EnumSpec :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/enumspec"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-enumspec",
          "prompt": "Produce a canonical EnumSpec value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.EnumSpec"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.EnumSpec",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.SchemaSpec",
      "category_path": [
        "core",
        "schemaspec"
      ],
      "description": "SchemaSpec — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.SchemaSpec",
        "data": {}
      },
      "canonical_lisp_shape": "(SchemaSpec :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/schemaspec"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-schemaspec",
          "prompt": "Produce a canonical SchemaSpec value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SchemaSpec"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.SchemaSpec",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Question",
      "category_path": [
        "core",
        "question"
      ],
      "description": "Question — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Question",
        "data": {}
      },
      "canonical_lisp_shape": "(Question :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/question"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-question",
          "prompt": "Produce a canonical Question value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Question"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Question",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Answer",
      "category_path": [
        "core",
        "answer"
      ],
      "description": "Answer — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Answer",
        "data": {}
      },
      "canonical_lisp_shape": "(Answer :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/answer"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-answer",
          "prompt": "Produce a canonical Answer value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Answer"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Answer",
            "text": "...",
            "evidence": [
              "..."
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Claim",
      "category_path": [
        "core",
        "claim"
      ],
      "description": "Claim — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Claim",
        "data": {}
      },
      "canonical_lisp_shape": "(Claim :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/claim"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-claim",
          "prompt": "Produce a canonical Claim value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Claim",
            "text": "...",
            "evidence": [
              "..."
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Hypothesis",
      "category_path": [
        "core",
        "hypothesis"
      ],
      "description": "Hypothesis — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Hypothesis",
        "data": {}
      },
      "canonical_lisp_shape": "(Hypothesis :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/hypothesis"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-hypothesis",
          "prompt": "Produce a canonical Hypothesis value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Hypothesis"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Hypothesis",
            "text": "...",
            "evidence": [
              "..."
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Decision",
      "category_path": [
        "core",
        "decision"
      ],
      "description": "Decision — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Decision",
        "data": {}
      },
      "canonical_lisp_shape": "(Decision :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/decision"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-decision",
          "prompt": "Produce a canonical Decision value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Decision"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Decision",
            "text": "...",
            "evidence": [
              "..."
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Summary",
      "category_path": [
        "core",
        "summary"
      ],
      "description": "Summary — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Summary",
        "data": {}
      },
      "canonical_lisp_shape": "(Summary :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/summary"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-summary",
          "prompt": "Produce a canonical Summary value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Summary"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Summary",
            "text": "...",
            "evidence": [
              "..."
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.TagSet",
      "category_path": [
        "core",
        "tagset"
      ],
      "description": "TagSet — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.TagSet",
        "data": {}
      },
      "canonical_lisp_shape": "(TagSet :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/tagset"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-tagset",
          "prompt": "Produce a canonical TagSet value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.TagSet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.TagSet",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.RiskAssessment",
      "category_path": [
        "core",
        "riskassessment"
      ],
      "description": "RiskAssessment — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.RiskAssessment",
        "data": {}
      },
      "canonical_lisp_shape": "(RiskAssessment :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/riskassessment"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-riskassessment",
          "prompt": "Produce a canonical RiskAssessment value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.RiskAssessment"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.RiskAssessment",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.Warning",
      "category_path": [
        "core",
        "warning"
      ],
      "description": "Warning — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.Warning",
        "data": {}
      },
      "canonical_lisp_shape": "(Warning :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/warning"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-warning",
          "prompt": "Produce a canonical Warning value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Warning"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.Warning",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Core.ErrorReport",
      "category_path": [
        "core",
        "errorreport"
      ],
      "description": "ErrorReport — Core-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Core.ErrorReport",
        "data": {}
      },
      "canonical_lisp_shape": "(ErrorReport :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.normalize",
        "CPO.coerce_schema",
        "CPO.coerce_enum"
      ],
      "typical_algorithms": [
        "CA.normalization.meaning_normal_form",
        "CA.caching.semantic_memoization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/errorreport"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-errorreport",
          "prompt": "Produce a canonical ErrorReport value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.ErrorReport"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Core.ErrorReport",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Evidence.SpanRef",
      "category_path": [
        "evidence",
        "spanref"
      ],
      "description": "SpanRef — Evidence-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Evidence.SpanRef",
        "data": {}
      },
      "canonical_lisp_shape": "(SpanRef :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.cite",
        "CPO.normalize",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/spanref"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-spanref",
          "prompt": "Produce a canonical SpanRef value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.SpanRef"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Evidence.SpanRef",
            "uri": "matrix://...",
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Evidence.RowRef",
      "category_path": [
        "evidence",
        "rowref"
      ],
      "description": "RowRef — Evidence-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Evidence.RowRef",
        "data": {}
      },
      "canonical_lisp_shape": "(RowRef :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.cite",
        "CPO.normalize",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/rowref"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-rowref",
          "prompt": "Produce a canonical RowRef value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.RowRef"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Evidence.RowRef",
            "uri": "matrix://...",
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Evidence.ClauseRef",
      "category_path": [
        "evidence",
        "clauseref"
      ],
      "description": "ClauseRef — Evidence-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Evidence.ClauseRef",
        "data": {}
      },
      "canonical_lisp_shape": "(ClauseRef :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.cite",
        "CPO.normalize",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/clauseref"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-clauseref",
          "prompt": "Produce a canonical ClauseRef value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.ClauseRef"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Evidence.ClauseRef",
            "uri": "matrix://...",
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Evidence.Citation",
      "category_path": [
        "evidence",
        "citation"
      ],
      "description": "Citation — Evidence-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Evidence.Citation",
        "data": {}
      },
      "canonical_lisp_shape": "(Citation :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.cite",
        "CPO.normalize",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/citation"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-citation",
          "prompt": "Produce a canonical Citation value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.Citation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Evidence.Citation",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Evidence.EvidenceSet",
      "category_path": [
        "evidence",
        "evidenceset"
      ],
      "description": "EvidenceSet — Evidence-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Evidence.EvidenceSet",
        "data": {}
      },
      "canonical_lisp_shape": "(EvidenceSet :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.cite",
        "CPO.normalize",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/evidenceset"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-evidenceset",
          "prompt": "Produce a canonical EvidenceSet value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.EvidenceSet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Evidence.EvidenceSet",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Provenance.Receipt",
      "category_path": [
        "provenance",
        "receipt"
      ],
      "description": "Receipt — Provenance-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Provenance.Receipt",
        "data": {}
      },
      "canonical_lisp_shape": "(Receipt :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.emit_provenance",
        "CPO.record_receipt",
        "CPO.replay_receipt"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/receipt"
        ],
        "view_types": [
          "EvidenceView",
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-receipt",
          "prompt": "Produce a canonical Receipt value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Provenance.Receipt"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Provenance.Receipt",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Provenance.ProvenanceNode",
      "category_path": [
        "provenance",
        "provenancenode"
      ],
      "description": "ProvenanceNode — Provenance-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Provenance.ProvenanceNode",
        "data": {}
      },
      "canonical_lisp_shape": "(ProvenanceNode :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.emit_provenance",
        "CPO.record_receipt",
        "CPO.replay_receipt"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/provenancenode"
        ],
        "view_types": [
          "EvidenceView",
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-provenancenode",
          "prompt": "Produce a canonical ProvenanceNode value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Provenance.ProvenanceNode"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Provenance.ProvenanceNode",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Provenance.ProvenanceEdge",
      "category_path": [
        "provenance",
        "provenanceedge"
      ],
      "description": "ProvenanceEdge — Provenance-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Provenance.ProvenanceEdge",
        "data": {}
      },
      "canonical_lisp_shape": "(ProvenanceEdge :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.emit_provenance",
        "CPO.record_receipt",
        "CPO.replay_receipt"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/provenanceedge"
        ],
        "view_types": [
          "EvidenceView",
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-provenanceedge",
          "prompt": "Produce a canonical ProvenanceEdge value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Provenance.ProvenanceEdge"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Provenance.ProvenanceEdge",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Provenance.ProvenanceDAG",
      "category_path": [
        "provenance",
        "provenancedag"
      ],
      "description": "ProvenanceDAG — Provenance-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Provenance.ProvenanceDAG",
        "data": {}
      },
      "canonical_lisp_shape": "(ProvenanceDAG :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.emit_provenance",
        "CPO.record_receipt",
        "CPO.replay_receipt"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/provenancedag"
        ],
        "view_types": [
          "EvidenceView",
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-provenancedag",
          "prompt": "Produce a canonical ProvenanceDAG value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Provenance.ProvenanceDAG"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Provenance.ProvenanceDAG",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Provenance.AuditTrail",
      "category_path": [
        "provenance",
        "audittrail"
      ],
      "description": "AuditTrail — Provenance-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Provenance.AuditTrail",
        "data": {}
      },
      "canonical_lisp_shape": "(AuditTrail :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Evidence references must validate against SnapshotRef content hashes."
      ],
      "core_operations": [
        "CPO.emit_provenance",
        "CPO.record_receipt",
        "CPO.replay_receipt"
      ],
      "typical_algorithms": [
        "CA.provenance.provenance_dag_build",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/audittrail"
        ],
        "view_types": [
          "EvidenceView",
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-audittrail",
          "prompt": "Produce a canonical AuditTrail value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Provenance.AuditTrail"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Provenance.AuditTrail",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Plan.OmegaIR",
      "category_path": [
        "plan",
        "omegair"
      ],
      "description": "OmegaIR — Plan-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Plan.OmegaIR",
        "data": {}
      },
      "canonical_lisp_shape": "(OmegaIR :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Plan nodes must carry SemanticContract for each effect boundary."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.compile",
        "CPO.execute_plan"
      ],
      "typical_algorithms": [
        "CA.compilation.nl_to_omega_ir",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/omegair"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-omegair",
          "prompt": "Produce a canonical OmegaIR value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.OmegaIR"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Plan.OmegaIR",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Plan.QueryPlan",
      "category_path": [
        "plan",
        "queryplan"
      ],
      "description": "QueryPlan — Plan-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Plan.QueryPlan",
        "data": {}
      },
      "canonical_lisp_shape": "(QueryPlan :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Plan nodes must carry SemanticContract for each effect boundary."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.compile",
        "CPO.execute_plan"
      ],
      "typical_algorithms": [
        "CA.compilation.nl_to_omega_ir",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/queryplan"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-queryplan",
          "prompt": "Produce a canonical QueryPlan value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.QueryPlan"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Plan.QueryPlan",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Plan.Bytecode",
      "category_path": [
        "plan",
        "bytecode"
      ],
      "description": "Bytecode — Plan-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Plan.Bytecode",
        "data": {}
      },
      "canonical_lisp_shape": "(Bytecode :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Plan nodes must carry SemanticContract for each effect boundary."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.compile",
        "CPO.execute_plan"
      ],
      "typical_algorithms": [
        "CA.compilation.nl_to_omega_ir",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/bytecode"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-bytecode",
          "prompt": "Produce a canonical Bytecode value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.Bytecode"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Plan.Bytecode",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Plan.ExecutionTrace",
      "category_path": [
        "plan",
        "executiontrace"
      ],
      "description": "ExecutionTrace — Plan-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Plan.ExecutionTrace",
        "data": {}
      },
      "canonical_lisp_shape": "(ExecutionTrace :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Plan nodes must carry SemanticContract for each effect boundary."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.compile",
        "CPO.execute_plan"
      ],
      "typical_algorithms": [
        "CA.compilation.nl_to_omega_ir",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/executiontrace"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-executiontrace",
          "prompt": "Produce a canonical ExecutionTrace value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.ExecutionTrace"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Plan.ExecutionTrace",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Plan.ToolInvocation",
      "category_path": [
        "plan",
        "toolinvocation"
      ],
      "description": "ToolInvocation — Plan-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Plan.ToolInvocation",
        "data": {}
      },
      "canonical_lisp_shape": "(ToolInvocation :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Plan nodes must carry SemanticContract for each effect boundary."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.compile",
        "CPO.execute_plan"
      ],
      "typical_algorithms": [
        "CA.compilation.nl_to_omega_ir",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/toolinvocation"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "QueryPort",
          "ViewPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-toolinvocation",
          "prompt": "Produce a canonical ToolInvocation value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.ToolInvocation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Plan.ToolInvocation",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.RelationalView",
      "category_path": [
        "view",
        "relationalview"
      ],
      "description": "RelationalView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.RelationalView",
        "data": {}
      },
      "canonical_lisp_shape": "(RelationalView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/users?view=relational"
        ],
        "view_types": [
          "RelationalView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-relationalview",
          "prompt": "Construct a RelationalView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.RelationalView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.RelationalView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.ASTView",
      "category_path": [
        "view",
        "astview"
      ],
      "description": "ASTView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.ASTView",
        "data": {}
      },
      "canonical_lisp_shape": "(ASTView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/main.ts?view=ast"
        ],
        "view_types": [
          "ASTView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-astview",
          "prompt": "Construct a ASTView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.ASTView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.ASTView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.ClauseView",
      "category_path": [
        "view",
        "clauseview"
      ],
      "description": "ClauseView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.ClauseView",
        "data": {}
      },
      "canonical_lisp_shape": "(ClauseView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/contract.pdf?view=clause"
        ],
        "view_types": [
          "ClauseView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-clauseview",
          "prompt": "Construct a ClauseView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.ClauseView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.ClauseView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.TimelineView",
      "category_path": [
        "view",
        "timelineview"
      ],
      "description": "TimelineView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.TimelineView",
        "data": {}
      },
      "canonical_lisp_shape": "(TimelineView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/logs/service.log?view=timeline"
        ],
        "view_types": [
          "TimelineView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-timelineview",
          "prompt": "Construct a TimelineView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.TimelineView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.TimelineView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.DialogueView",
      "category_path": [
        "view",
        "dialogueview"
      ],
      "description": "DialogueView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.DialogueView",
        "data": {}
      },
      "canonical_lisp_shape": "(DialogueView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=dialogueview"
        ],
        "view_types": [
          "DialogueView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dialogueview",
          "prompt": "Construct a DialogueView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.DialogueView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.DialogueView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.EvidenceView",
      "category_path": [
        "view",
        "evidenceview"
      ],
      "description": "EvidenceView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.EvidenceView",
        "data": {}
      },
      "canonical_lisp_shape": "(EvidenceView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=evidenceview"
        ],
        "view_types": [
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-evidenceview",
          "prompt": "Construct a EvidenceView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.EvidenceView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.EvidenceView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.GraphView",
      "category_path": [
        "view",
        "graphview"
      ],
      "description": "GraphView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.GraphView",
        "data": {}
      },
      "canonical_lisp_shape": "(GraphView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=graphview"
        ],
        "view_types": [
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-graphview",
          "prompt": "Construct a GraphView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.GraphView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.GraphView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.StateMachineView",
      "category_path": [
        "view",
        "statemachineview"
      ],
      "description": "StateMachineView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.StateMachineView",
        "data": {}
      },
      "canonical_lisp_shape": "(StateMachineView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=statemachineview"
        ],
        "view_types": [
          "StateMachineView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-statemachineview",
          "prompt": "Construct a StateMachineView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.StateMachineView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.StateMachineView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.APIView",
      "category_path": [
        "view",
        "apiview"
      ],
      "description": "APIView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.APIView",
        "data": {}
      },
      "canonical_lisp_shape": "(APIView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=apiview"
        ],
        "view_types": [
          "APIView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-apiview",
          "prompt": "Construct a APIView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.APIView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.APIView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.ConfigView",
      "category_path": [
        "view",
        "configview"
      ],
      "description": "ConfigView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.ConfigView",
        "data": {}
      },
      "canonical_lisp_shape": "(ConfigView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=configview"
        ],
        "view_types": [
          "ConfigView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-configview",
          "prompt": "Construct a ConfigView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.ConfigView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.ConfigView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.MetricView",
      "category_path": [
        "view",
        "metricview"
      ],
      "description": "MetricView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.MetricView",
        "data": {}
      },
      "canonical_lisp_shape": "(MetricView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=metricview"
        ],
        "view_types": [
          "MetricView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-metricview",
          "prompt": "Construct a MetricView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.MetricView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.MetricView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.TraceView",
      "category_path": [
        "view",
        "traceview"
      ],
      "description": "TraceView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.TraceView",
        "data": {}
      },
      "canonical_lisp_shape": "(TraceView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=traceview"
        ],
        "view_types": [
          "TraceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-traceview",
          "prompt": "Construct a TraceView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.TraceView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.TraceView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.UIComponentView",
      "category_path": [
        "view",
        "uicomponentview"
      ],
      "description": "UIComponentView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.UIComponentView",
        "data": {}
      },
      "canonical_lisp_shape": "(UIComponentView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/app/ui/root?view=component-tree"
        ],
        "view_types": [
          "UIComponentView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-uicomponentview",
          "prompt": "Construct a UIComponentView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.UIComponentView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.UIComponentView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.View.DeviceView",
      "category_path": [
        "view",
        "deviceview"
      ],
      "description": "DeviceView — View-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.View.DeviceView",
        "data": {}
      },
      "canonical_lisp_shape": "(DeviceView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.view",
        "CPO.query",
        "CPO.extract"
      ],
      "typical_algorithms": [
        "CA.machine.streaming_scatter_gather",
        "CA.machine.cognitive_vm_execute"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/resource?view=deviceview"
        ],
        "view_types": [
          "DeviceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-deviceview",
          "prompt": "Construct a DeviceView for the addressed artifact and expose minimal schema.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.View.DeviceView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.View.DeviceView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Science.ExperimentDesign",
      "category_path": [
        "science",
        "experimentdesign"
      ],
      "description": "ExperimentDesign — Science-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Science.ExperimentDesign",
        "data": {}
      },
      "canonical_lisp_shape": "(ExperimentDesign :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.summarize",
        "CPO.judge"
      ],
      "typical_algorithms": [
        "CA.search.generate_and_test",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/lab/experiment/exp-001#experimentdesign"
        ],
        "view_types": [
          "RelationalView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-experimentdesign",
          "prompt": "Describe an ExperimentDesign from requirements with explicit variables and controls.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Science.ExperimentDesign"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Science.ExperimentDesign",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.FunctionSignature",
      "category_path": [
        "code",
        "functionsignature"
      ],
      "description": "FunctionSignature — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.FunctionSignature",
        "data": {}
      },
      "canonical_lisp_shape": "(FunctionSignature :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#functionsignature=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-functionsignature",
          "prompt": "Extract a FunctionSignature from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.FunctionSignature"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.FunctionSignature",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ClassModel",
      "category_path": [
        "code",
        "classmodel"
      ],
      "description": "ClassModel — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ClassModel",
        "data": {}
      },
      "canonical_lisp_shape": "(ClassModel :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#classmodel=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-classmodel",
          "prompt": "Extract a ClassModel from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ClassModel"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ClassModel",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ModulePurpose",
      "category_path": [
        "code",
        "modulepurpose"
      ],
      "description": "ModulePurpose — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ModulePurpose",
        "data": {}
      },
      "canonical_lisp_shape": "(ModulePurpose :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#modulepurpose=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-modulepurpose",
          "prompt": "Extract a ModulePurpose from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ModulePurpose"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ModulePurpose",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.DependencyGraph",
      "category_path": [
        "code",
        "dependencygraph"
      ],
      "description": "DependencyGraph — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.DependencyGraph",
        "data": {}
      },
      "canonical_lisp_shape": "(DependencyGraph :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#dependencygraph=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dependencygraph",
          "prompt": "Extract a DependencyGraph from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.DependencyGraph"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.DependencyGraph",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.CallGraph",
      "category_path": [
        "code",
        "callgraph"
      ],
      "description": "CallGraph — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.CallGraph",
        "data": {}
      },
      "canonical_lisp_shape": "(CallGraph :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#callgraph=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-callgraph",
          "prompt": "Extract a CallGraph from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.CallGraph"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.CallGraph",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.DataFlowGraph",
      "category_path": [
        "code",
        "dataflowgraph"
      ],
      "description": "DataFlowGraph — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.DataFlowGraph",
        "data": {}
      },
      "canonical_lisp_shape": "(DataFlowGraph :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#dataflowgraph=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dataflowgraph",
          "prompt": "Extract a DataFlowGraph from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.DataFlowGraph"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.DataFlowGraph",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.SecurityFinding",
      "category_path": [
        "code",
        "securityfinding"
      ],
      "description": "SecurityFinding — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.SecurityFinding",
        "data": {}
      },
      "canonical_lisp_shape": "(SecurityFinding :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#securityfinding=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-securityfinding",
          "prompt": "Extract a SecurityFinding from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.SecurityFinding"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.SecurityFinding",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.RefactoringOpportunity",
      "category_path": [
        "code",
        "refactoringopportunity"
      ],
      "description": "RefactoringOpportunity — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.RefactoringOpportunity",
        "data": {}
      },
      "canonical_lisp_shape": "(RefactoringOpportunity :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#refactoringopportunity=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-refactoringopportunity",
          "prompt": "Extract a RefactoringOpportunity from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.RefactoringOpportunity"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.RefactoringOpportunity",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.TestSpec",
      "category_path": [
        "code",
        "testspec"
      ],
      "description": "TestSpec — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.TestSpec",
        "data": {}
      },
      "canonical_lisp_shape": "(TestSpec :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#testspec=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-testspec",
          "prompt": "Extract a TestSpec from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.TestSpec"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.TestSpec",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.PropertySpec",
      "category_path": [
        "code",
        "propertyspec"
      ],
      "description": "PropertySpec — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.PropertySpec",
        "data": {}
      },
      "canonical_lisp_shape": "(PropertySpec :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#propertyspec=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-propertyspec",
          "prompt": "Extract a PropertySpec from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.PropertySpec"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.PropertySpec",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.BuildGraph",
      "category_path": [
        "code",
        "buildgraph"
      ],
      "description": "BuildGraph — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.BuildGraph",
        "data": {}
      },
      "canonical_lisp_shape": "(BuildGraph :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#buildgraph=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-buildgraph",
          "prompt": "Extract a BuildGraph from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.BuildGraph"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.BuildGraph",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.CIResult",
      "category_path": [
        "code",
        "ciresult"
      ],
      "description": "CIResult — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.CIResult",
        "data": {}
      },
      "canonical_lisp_shape": "(CIResult :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#ciresult=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-ciresult",
          "prompt": "Extract a CIResult from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.CIResult"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.CIResult",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ChangeSet",
      "category_path": [
        "code",
        "changeset"
      ],
      "description": "ChangeSet — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ChangeSet",
        "data": {}
      },
      "canonical_lisp_shape": "(ChangeSet :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#changeset=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-changeset",
          "prompt": "Extract a ChangeSet from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ChangeSet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ChangeSet",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.Patch",
      "category_path": [
        "code",
        "patch"
      ],
      "description": "Patch — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.Patch",
        "data": {}
      },
      "canonical_lisp_shape": "(Patch :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#patch=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-patch",
          "prompt": "Extract a Patch from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.Patch"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.Patch",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ADRView",
      "category_path": [
        "code",
        "adrview"
      ],
      "description": "ADRView — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ADRView",
        "data": {}
      },
      "canonical_lisp_shape": "(ADRView :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#adrview=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-adrview",
          "prompt": "Extract a ADRView from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ADRView"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ADRView",
            "schema": {
              "...": "..."
            },
            "snapshot_id": "sha256:..."
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.Constraint",
      "category_path": [
        "code",
        "constraint"
      ],
      "description": "Constraint — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.Constraint",
        "data": {}
      },
      "canonical_lisp_shape": "(Constraint :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#constraint=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-constraint",
          "prompt": "Extract a Constraint from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.Constraint"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.Constraint",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ConstraintNetwork",
      "category_path": [
        "code",
        "constraintnetwork"
      ],
      "description": "ConstraintNetwork — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ConstraintNetwork",
        "data": {}
      },
      "canonical_lisp_shape": "(ConstraintNetwork :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#constraintnetwork=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-constraintnetwork",
          "prompt": "Extract a ConstraintNetwork from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ConstraintNetwork"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ConstraintNetwork",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Code.ConstraintViolation",
      "category_path": [
        "code",
        "constraintviolation"
      ],
      "description": "ConstraintViolation — Code-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Code.ConstraintViolation",
        "data": {}
      },
      "canonical_lisp_shape": "(ConstraintViolation :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.classify",
        "CPO.generate_patch"
      ],
      "typical_algorithms": [
        "CA.search.best_first",
        "CA.constraints.specification_checking"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/project/src/module.ts#constraintviolation=..."
        ],
        "view_types": [
          "ASTView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-constraintviolation",
          "prompt": "Extract a ConstraintViolation from the code artifact and return structured fields.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ConstraintViolation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Code.ConstraintViolation",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.TableSchema",
      "category_path": [
        "data",
        "tableschema"
      ],
      "description": "TableSchema — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.TableSchema",
        "data": {}
      },
      "canonical_lisp_shape": "(TableSchema :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/tableschema"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-tableschema",
          "prompt": "Given a table and query intent, return a TableSchema with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.TableSchema"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.TableSchema",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.ColumnSchema",
      "category_path": [
        "data",
        "columnschema"
      ],
      "description": "ColumnSchema — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.ColumnSchema",
        "data": {}
      },
      "canonical_lisp_shape": "(ColumnSchema :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/columnschema"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-columnschema",
          "prompt": "Given a table and query intent, return a ColumnSchema with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.ColumnSchema"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.ColumnSchema",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.SQLAST",
      "category_path": [
        "data",
        "sqlast"
      ],
      "description": "SQLAST — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.SQLAST",
        "data": {}
      },
      "canonical_lisp_shape": "(SQLAST :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/sqlast"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-sqlast",
          "prompt": "Given a table and query intent, return a SQLAST with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.SQLAST"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.SQLAST",
            "select": [
              "..."
            ],
            "from": "...",
            "where": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.QueryResultSet",
      "category_path": [
        "data",
        "queryresultset"
      ],
      "description": "QueryResultSet — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.QueryResultSet",
        "data": {}
      },
      "canonical_lisp_shape": "(QueryResultSet :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/queryresultset"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-queryresultset",
          "prompt": "Given a table and query intent, return a QueryResultSet with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.QueryResultSet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.QueryResultSet",
            "columns": [
              "..."
            ],
            "rows": [
              [
                "..."
              ]
            ]
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.MetricDefinition",
      "category_path": [
        "data",
        "metricdefinition"
      ],
      "description": "MetricDefinition — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.MetricDefinition",
        "data": {}
      },
      "canonical_lisp_shape": "(MetricDefinition :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/metricdefinition"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-metricdefinition",
          "prompt": "Given a table and query intent, return a MetricDefinition with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.MetricDefinition"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.MetricDefinition",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.DimensionalModel",
      "category_path": [
        "data",
        "dimensionalmodel"
      ],
      "description": "DimensionalModel — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.DimensionalModel",
        "data": {}
      },
      "canonical_lisp_shape": "(DimensionalModel :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/dimensionalmodel"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dimensionalmodel",
          "prompt": "Given a table and query intent, return a DimensionalModel with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.DimensionalModel"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.DimensionalModel",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.LineageGraph",
      "category_path": [
        "data",
        "lineagegraph"
      ],
      "description": "LineageGraph — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.LineageGraph",
        "data": {}
      },
      "canonical_lisp_shape": "(LineageGraph :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/lineagegraph"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-lineagegraph",
          "prompt": "Given a table and query intent, return a LineageGraph with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.LineageGraph"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.LineageGraph",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.DataQualityReport",
      "category_path": [
        "data",
        "dataqualityreport"
      ],
      "description": "DataQualityReport — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.DataQualityReport",
        "data": {}
      },
      "canonical_lisp_shape": "(DataQualityReport :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/dataqualityreport"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dataqualityreport",
          "prompt": "Given a table and query intent, return a DataQualityReport with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.DataQualityReport"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.DataQualityReport",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.Anomaly",
      "category_path": [
        "data",
        "anomaly"
      ],
      "description": "Anomaly — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.Anomaly",
        "data": {}
      },
      "canonical_lisp_shape": "(Anomaly :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/anomaly"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-anomaly",
          "prompt": "Given a table and query intent, return a Anomaly with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.Anomaly"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.Anomaly",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.ForecastNarrative",
      "category_path": [
        "data",
        "forecastnarrative"
      ],
      "description": "ForecastNarrative — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.ForecastNarrative",
        "data": {}
      },
      "canonical_lisp_shape": "(ForecastNarrative :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/forecastnarrative"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-forecastnarrative",
          "prompt": "Given a table and query intent, return a ForecastNarrative with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.ForecastNarrative"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.ForecastNarrative",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.SegmentDefinition",
      "category_path": [
        "data",
        "segmentdefinition"
      ],
      "description": "SegmentDefinition — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.SegmentDefinition",
        "data": {}
      },
      "canonical_lisp_shape": "(SegmentDefinition :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/segmentdefinition"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-segmentdefinition",
          "prompt": "Given a table and query intent, return a SegmentDefinition with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.SegmentDefinition"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.SegmentDefinition",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Data.CohortDefinition",
      "category_path": [
        "data",
        "cohortdefinition"
      ],
      "description": "CohortDefinition — Data-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Data.CohortDefinition",
        "data": {}
      },
      "canonical_lisp_shape": "(CohortDefinition :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Schema uses stable column ids; ordering is explicit, never implicit."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.extract",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.cognitive_vm_execute",
        "CA.compilation.cost_based_planner"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/db/cohortdefinition"
        ],
        "view_types": [
          "RelationalView",
          "GraphView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-cohortdefinition",
          "prompt": "Given a table and query intent, return a CohortDefinition with evidence references.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Data.CohortDefinition"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Data.CohortDefinition",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.Clause",
      "category_path": [
        "legal",
        "clause"
      ],
      "description": "Clause — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.Clause",
        "data": {}
      },
      "canonical_lisp_shape": "(Clause :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#clause=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-clause",
          "prompt": "Extract Clause units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.Clause"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.Clause",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.Obligation",
      "category_path": [
        "legal",
        "obligation"
      ],
      "description": "Obligation — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.Obligation",
        "data": {}
      },
      "canonical_lisp_shape": "(Obligation :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#obligation=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-obligation",
          "prompt": "Extract Obligation units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.Obligation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.Obligation",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.Permission",
      "category_path": [
        "legal",
        "permission"
      ],
      "description": "Permission — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.Permission",
        "data": {}
      },
      "canonical_lisp_shape": "(Permission :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#permission=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-permission",
          "prompt": "Extract Permission units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.Permission"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.Permission",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.Prohibition",
      "category_path": [
        "legal",
        "prohibition"
      ],
      "description": "Prohibition — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.Prohibition",
        "data": {}
      },
      "canonical_lisp_shape": "(Prohibition :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#prohibition=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-prohibition",
          "prompt": "Extract Prohibition units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.Prohibition"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.Prohibition",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.PolicyDecision",
      "category_path": [
        "legal",
        "policydecision"
      ],
      "description": "PolicyDecision — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.PolicyDecision",
        "data": {}
      },
      "canonical_lisp_shape": "(PolicyDecision :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#policydecision=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-policydecision",
          "prompt": "Extract PolicyDecision units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.PolicyDecision"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.PolicyDecision",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.RedlinePatch",
      "category_path": [
        "legal",
        "redlinepatch"
      ],
      "description": "RedlinePatch — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.RedlinePatch",
        "data": {}
      },
      "canonical_lisp_shape": "(RedlinePatch :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#redlinepatch=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-redlinepatch",
          "prompt": "Extract RedlinePatch units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.RedlinePatch"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.RedlinePatch",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.ComplianceRequirement",
      "category_path": [
        "legal",
        "compliancerequirement"
      ],
      "description": "ComplianceRequirement — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.ComplianceRequirement",
        "data": {}
      },
      "canonical_lisp_shape": "(ComplianceRequirement :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#compliancerequirement=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-compliancerequirement",
          "prompt": "Extract ComplianceRequirement units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.ComplianceRequirement"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.ComplianceRequirement",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.DataRetentionRule",
      "category_path": [
        "legal",
        "dataretentionrule"
      ],
      "description": "DataRetentionRule — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.DataRetentionRule",
        "data": {}
      },
      "canonical_lisp_shape": "(DataRetentionRule :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#dataretentionrule=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-dataretentionrule",
          "prompt": "Extract DataRetentionRule units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.DataRetentionRule"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.DataRetentionRule",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Legal.AccessControlRule",
      "category_path": [
        "legal",
        "accesscontrolrule"
      ],
      "description": "AccessControlRule — Legal-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Legal.AccessControlRule",
        "data": {}
      },
      "canonical_lisp_shape": "(AccessControlRule :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies.",
        "Deontic modality is explicit (obligation/permission/prohibition) with scope."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.judge",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.constraints.policy_consistency",
        "CA.provenance.citation_synthesis"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/docs/policy.md#accesscontrolrule=..."
        ],
        "view_types": [
          "ClauseView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-accesscontrolrule",
          "prompt": "Extract AccessControlRule units from the document and return normalized deontic structure.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Legal.AccessControlRule"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Legal.AccessControlRule",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.LogEvent",
      "category_path": [
        "ops",
        "logevent"
      ],
      "description": "LogEvent — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.LogEvent",
        "data": {}
      },
      "canonical_lisp_shape": "(LogEvent :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/logevent?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-logevent",
          "prompt": "Summarize operational signal into LogEvent with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.LogEvent"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.LogEvent",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.IncidentReport",
      "category_path": [
        "ops",
        "incidentreport"
      ],
      "description": "IncidentReport — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.IncidentReport",
        "data": {}
      },
      "canonical_lisp_shape": "(IncidentReport :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/incidentreport?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-incidentreport",
          "prompt": "Summarize operational signal into IncidentReport with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.IncidentReport"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.IncidentReport",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.RunbookStep",
      "category_path": [
        "ops",
        "runbookstep"
      ],
      "description": "RunbookStep — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.RunbookStep",
        "data": {}
      },
      "canonical_lisp_shape": "(RunbookStep :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/runbookstep?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-runbookstep",
          "prompt": "Summarize operational signal into RunbookStep with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.RunbookStep"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.RunbookStep",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.SLOViolation",
      "category_path": [
        "ops",
        "sloviolation"
      ],
      "description": "SLOViolation — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.SLOViolation",
        "data": {}
      },
      "canonical_lisp_shape": "(SLOViolation :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/sloviolation?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-sloviolation",
          "prompt": "Summarize operational signal into SLOViolation with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.SLOViolation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.SLOViolation",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.Alert",
      "category_path": [
        "ops",
        "alert"
      ],
      "description": "Alert — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.Alert",
        "data": {}
      },
      "canonical_lisp_shape": "(Alert :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/alert?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-alert",
          "prompt": "Summarize operational signal into Alert with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.Alert"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.Alert",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Ops.RootCauseTree",
      "category_path": [
        "ops",
        "rootcausetree"
      ],
      "description": "RootCauseTree — Ops-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Ops.RootCauseTree",
        "data": {}
      },
      "canonical_lisp_shape": "(RootCauseTree :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.extract",
        "CPO.aggregate",
        "CPO.summarize"
      ],
      "typical_algorithms": [
        "CA.machine.resequencer_ordering",
        "CA.normalization.consensus_merge"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/ops/rootcausetree?day=2026-01-31"
        ],
        "view_types": [
          "TimelineView",
          "TraceView"
        ],
        "ports_used": [
          "EventPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-rootcausetree",
          "prompt": "Summarize operational signal into RootCauseTree with timestamped evidence.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Ops.RootCauseTree"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Ops.RootCauseTree",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.UI.UIActionPlan",
      "category_path": [
        "ui",
        "uiactionplan"
      ],
      "description": "UIActionPlan — UI-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.UI.UIActionPlan",
        "data": {}
      },
      "canonical_lisp_shape": "(UIActionPlan :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.plan",
        "CPO.command",
        "CPO.emit_provenance"
      ],
      "typical_algorithms": [
        "CA.planning.htn_synthesis",
        "CA.concurrency.serializer"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/object/uiactionplan"
        ],
        "view_types": [
          "UIComponentView"
        ],
        "ports_used": [
          "CommandPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-uiactionplan",
          "prompt": "Produce a canonical UIActionPlan value from the given input.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.UI.UIActionPlan"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.UI.UIActionPlan",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.IoT.DeviceState",
      "category_path": [
        "iot",
        "devicestate"
      ],
      "description": "DeviceState — IoT-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.IoT.DeviceState",
        "data": {}
      },
      "canonical_lisp_shape": "(DeviceState :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.query",
        "CPO.command",
        "CPO.aggregate"
      ],
      "typical_algorithms": [
        "CA.search.topk_sampling",
        "CA.normalization.idempotent_canonicalization"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/home/device/devicestate"
        ],
        "view_types": [
          "TimelineView"
        ],
        "ports_used": [
          "StatePort",
          "QueryPort",
          "CommandPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-devicestate",
          "prompt": "Summarize device telemetry into DeviceState with anomalies and baseline.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.IoT.DeviceState"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.IoT.DeviceState",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    },
    {
      "name": "CDT.Medical.PatientSummary",
      "category_path": [
        "medical",
        "patientsummary"
      ],
      "description": "PatientSummary — Medical-scoped cognitive data type with canonical MNF-normalized representation.",
      "canonical_json_shape": {
        "_type": "CDT.Medical.PatientSummary",
        "data": {}
      },
      "canonical_lisp_shape": "(PatientSummary :data ...)",
      "invariants": [
        "Has explicit _type tag equal to CDT name.",
        "All nested references are URI+SnapshotRef based, not raw string copies."
      ],
      "core_operations": [
        "CPO.summarize",
        "CPO.extract",
        "CPO.redact"
      ],
      "typical_algorithms": [
        "CA.provenance.evidence_weaving",
        "CA.constraints.policy_consistency"
      ],
      "matrix": {
        "example_uris": [
          "matrix://realm/clinic/patient/123#patientsummary"
        ],
        "view_types": [
          "RelationalView",
          "EvidenceView"
        ],
        "ports_used": [
          "ViewPort",
          "QueryPort"
        ]
      },
      "examples": [
        {
          "use_case": "canonicalize-patientsummary",
          "prompt": "Produce a PatientSummary from structured record data with redaction per Policy.",
          "contract": {
            "type": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Medical.PatientSummary"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "expected_output_shape": {
            "_type": "CDT.Medical.PatientSummary",
            "data": {
              "...": "..."
            }
          }
        }
      ],
      "tests": {
        "golden_master": "Snapshot serialized canonical form and compare on replay.",
        "contract_tests": [
          "Schema validation: required fields present; _type matches.",
          "Normalization idempotence: normalize(normalize(x)) == normalize(x)."
        ],
        "metamorphic_tests": [
          "Paraphrase-invariant: semantics preserved under rewording within same ENV.",
          "Reordering-invariant where applicable (sets/graphs): canonical sort yields same hash."
        ]
      }
    }
  ],
  "cpo_isa": [
    {
      "name": "CPO.capabilities",
      "signature": "[tier0] URI -> Effect<CapabilitySet>",
      "description": "CPO.capabilities — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (capabilities env ...)\n  (effect capabilities ...))"
    },
    {
      "name": "CPO.snapshot",
      "signature": "[tier0] URI -> Effect<SnapshotRef>",
      "description": "CPO.snapshot — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.SnapshotRef"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (snapshot env ...)\n  (effect snapshot ...))"
    },
    {
      "name": "CPO.view",
      "signature": "[tier0] (Env, URI, ViewSpec) -> Effect<View>",
      "description": "CPO.view — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "$ref": "matrix.views[*].contract_schema"
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (view env ...)\n  (effect view ...))"
    },
    {
      "name": "CPO.query",
      "signature": "[tier0] (Env, URI, Query, Contract) -> Effect<Result>",
      "description": "CPO.query — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (query env ...)\n  (effect query ...))"
    },
    {
      "name": "CPO.command",
      "signature": "[tier0] (Env, URI, Command, Contract) -> Effect<Receipt>",
      "description": "CPO.command — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (command env ...)\n  (effect command ...))"
    },
    {
      "name": "CPO.subscribe_events",
      "signature": "[tier0] (Env, URI, EventFilter) -> Effect<Stream<Event>>",
      "description": "CPO.subscribe_events — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (subscribe_events env ...)\n  (effect subscribe_events ...))"
    },
    {
      "name": "CPO.publish_event",
      "signature": "[tier0] (Env, URI, Event) -> Effect<Unit>",
      "description": "CPO.publish_event — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (publish_event env ...)\n  (effect publish_event ...))"
    },
    {
      "name": "CPO.normalize",
      "signature": "[tier1] (Env, Any) -> Effect<MNF>",
      "description": "CPO.normalize — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (normalize env ...)\n  (effect normalize ...))"
    },
    {
      "name": "CPO.cite",
      "signature": "[tier0] (Env, EvidenceRef) -> Effect<Citation>",
      "description": "CPO.cite — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Evidence.Citation"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (cite env ...)\n  (effect cite ...))"
    },
    {
      "name": "CPO.coerce_enum",
      "signature": "[tier2] (Env, Text, EnumSpec) -> Effect<EnumValue>",
      "description": "CPO.coerce_enum — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "enum",
          "payload": {
            "enum": [
              "..."
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (coerce_enum env ...)\n  (effect coerce_enum ...))"
    },
    {
      "name": "CPO.coerce_schema",
      "signature": "[tier2] (Env, Text|Any, SchemaSpec) -> Effect<StructuredValue>",
      "description": "CPO.coerce_schema — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (coerce_schema env ...)\n  (effect coerce_schema ...))"
    },
    {
      "name": "CPO.classify",
      "signature": "[tier2] (Env, View, Taxonomy) -> Effect<TagSet>",
      "description": "CPO.classify — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.TagSet"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (classify env ...)\n  (effect classify ...))"
    },
    {
      "name": "CPO.extract",
      "signature": "[tier1] (Env, View, ExtractSpec) -> Effect<StructuredValue>",
      "description": "CPO.extract — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (extract env ...)\n  (effect extract ...))"
    },
    {
      "name": "CPO.summarize",
      "signature": "[tier2] (Env, View, SummarySpec) -> Effect<Summary>",
      "description": "CPO.summarize — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Summary"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (summarize env ...)\n  (effect summarize ...))"
    },
    {
      "name": "CPO.questionize",
      "signature": "[tier2] (Env, Goal, View) -> Effect<List<Question>>",
      "description": "CPO.questionize — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (questionize env ...)\n  (effect questionize ...))"
    },
    {
      "name": "CPO.judge",
      "signature": "[tier2] (Env, Claim, EvidenceView) -> Effect<ClaimJudgment>",
      "description": "CPO.judge — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (judge env ...)\n  (effect judge ...))"
    },
    {
      "name": "CPO.rank",
      "signature": "[tier2] (Env, List<Any>, RankingSpec) -> Effect<List<Ranked>>",
      "description": "CPO.rank — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (rank env ...)\n  (effect rank ...))"
    },
    {
      "name": "CPO.route",
      "signature": "[tier2] (Env, Question, CandidateURIs) -> Effect<List<URI>>",
      "description": "CPO.route — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (route env ...)\n  (effect route ...))"
    },
    {
      "name": "CPO.split",
      "signature": "[tier0] (Env, Question) -> Effect<List<Question>>",
      "description": "CPO.split — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (split env ...)\n  (effect split ...))"
    },
    {
      "name": "CPO.aggregate",
      "signature": "[tier0] (Env, List<Answer>, AggregateSpec) -> Effect<Answer>",
      "description": "CPO.aggregate — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (aggregate env ...)\n  (effect aggregate ...))"
    },
    {
      "name": "CPO.resequence",
      "signature": "[tier0] (Env, List<Event>, OrderingSpec) -> Effect<List<Event>>",
      "description": "CPO.resequence — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (resequence env ...)\n  (effect resequence ...))"
    },
    {
      "name": "CPO.plan",
      "signature": "[tier2] (Env, Question) -> Effect<OmegaIR>",
      "description": "CPO.plan — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Plan.OmegaIR"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (plan env ...)\n  (effect plan ...))"
    },
    {
      "name": "CPO.compile",
      "signature": "[tier0] (Env, OmegaIR, Topology) -> Effect<QueryPlan>",
      "description": "CPO.compile — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Plan.QueryPlan"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (compile env ...)\n  (effect compile ...))"
    },
    {
      "name": "CPO.optimize_ir",
      "signature": "[tier1] (Env, OmegaIR|QueryPlan) -> Effect<OmegaIR|QueryPlan>",
      "description": "CPO.optimize_ir — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (optimize_ir env ...)\n  (effect optimize_ir ...))"
    },
    {
      "name": "CPO.execute_plan",
      "signature": "[tier0] (Env, QueryPlan) -> Effect<Answer>",
      "description": "CPO.execute_plan — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (execute_plan env ...)\n  (effect execute_plan ...))"
    },
    {
      "name": "CPO.search",
      "signature": "[tier0] (Env, SearchSpec) -> Effect<List<ResultRef>>",
      "description": "CPO.search — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (search env ...)\n  (effect search ...))"
    },
    {
      "name": "CPO.lookup_ontology",
      "signature": "[tier1] (Env, Text, Ontology) -> Effect<List<EntityRef>>",
      "description": "CPO.lookup_ontology — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (lookup_ontology env ...)\n  (effect lookup_ontology ...))"
    },
    {
      "name": "CPO.check_constraints",
      "signature": "[tier1] (Env, ConstraintSet, State) -> Effect<List<ConstraintViolation>>",
      "description": "CPO.check_constraints — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Code.ConstraintViolation"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (check_constraints env ...)\n  (effect check_constraints ...))"
    },
    {
      "name": "CPO.propagate_constraints",
      "signature": "[tier1] (Env, ConstraintNetwork, Change) -> Effect<ConstraintNetwork>",
      "description": "CPO.propagate_constraints — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (propagate_constraints env ...)\n  (effect propagate_constraints ...))"
    },
    {
      "name": "CPO.generate_alternatives",
      "signature": "[tier2] (Env, Problem, Constraints) -> Effect<List<Candidate>>",
      "description": "CPO.generate_alternatives — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (generate_alternatives env ...)\n  (effect generate_alternatives ...))"
    },
    {
      "name": "CPO.select_candidate",
      "signature": "[tier2] (Env, List<Candidate>, SelectionPolicy) -> Effect<Decision>",
      "description": "CPO.select_candidate — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (select_candidate env ...)\n  (effect select_candidate ...))"
    },
    {
      "name": "CPO.generate_patch",
      "signature": "[tier1] (Env, RewriteSpec) -> Effect<Patch>",
      "description": "CPO.generate_patch — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Code.Patch"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (generate_patch env ...)\n  (effect generate_patch ...))"
    },
    {
      "name": "CPO.apply_patch",
      "signature": "[tier0] (Env, URI, Patch) -> Effect<Receipt>",
      "description": "CPO.apply_patch — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Provenance.Receipt"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (apply_patch env ...)\n  (effect apply_patch ...))"
    },
    {
      "name": "CPO.rollback_patch",
      "signature": "[tier0] (Env, URI, Receipt|Patch) -> Effect<Receipt>",
      "description": "CPO.rollback_patch — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (rollback_patch env ...)\n  (effect rollback_patch ...))"
    },
    {
      "name": "CPO.generate_tests",
      "signature": "[tier1] (Env, Spec, CodeView) -> Effect<TestSpec>",
      "description": "CPO.generate_tests — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (generate_tests env ...)\n  (effect generate_tests ...))"
    },
    {
      "name": "CPO.run_tests",
      "signature": "[tier0] (Env, TestPlan) -> Effect<TestRunResult>",
      "description": "CPO.run_tests — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (run_tests env ...)\n  (effect run_tests ...))"
    },
    {
      "name": "CPO.golden_master_record",
      "signature": "[tier0] (Env, Artifact, Output) -> Effect<GoldenMasterRef>",
      "description": "CPO.golden_master_record — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (golden_master_record env ...)\n  (effect golden_master_record ...))"
    },
    {
      "name": "CPO.golden_master_compare",
      "signature": "[tier0] (Env, GoldenMasterRef, Output) -> Effect<PassFail>",
      "description": "CPO.golden_master_compare — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "enum",
          "payload": {
            "enum": [
              "pass",
              "fail"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (golden_master_compare env ...)\n  (effect golden_master_compare ...))"
    },
    {
      "name": "CPO.metamorphic_check",
      "signature": "[tier1] (Env, MetamorphicSpec, Program) -> Effect<PassFail>",
      "description": "CPO.metamorphic_check — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "enum",
          "payload": {
            "enum": [
              "pass",
              "fail"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (metamorphic_check env ...)\n  (effect metamorphic_check ...))"
    },
    {
      "name": "CPO.consensus",
      "signature": "[tier1] (Env, List<Answer>, ConsensusPolicy) -> Effect<Answer>",
      "description": "CPO.consensus — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (consensus env ...)\n  (effect consensus ...))"
    },
    {
      "name": "CPO.emit_provenance",
      "signature": "[tier0] (Env, Receipt, Outputs) -> Effect<ProvenanceNode>",
      "description": "CPO.emit_provenance — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Provenance.ProvenanceNode"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (emit_provenance env ...)\n  (effect emit_provenance ...))"
    },
    {
      "name": "CPO.minimize_provenance",
      "signature": "[tier1] (Env, ProvenanceDAG, Goal) -> Effect<ProvenanceDAG>",
      "description": "CPO.minimize_provenance — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (minimize_provenance env ...)\n  (effect minimize_provenance ...))"
    },
    {
      "name": "CPO.record_receipt",
      "signature": "[tier0] (Env, Receipt) -> Effect<Unit>",
      "description": "CPO.record_receipt — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (record_receipt env ...)\n  (effect record_receipt ...))"
    },
    {
      "name": "CPO.replay_receipt",
      "signature": "[tier0] (Env, ReceiptLog, QueryPlan) -> Effect<Answer>",
      "description": "CPO.replay_receipt — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (replay_receipt env ...)\n  (effect replay_receipt ...))"
    },
    {
      "name": "CPO.semantic_fingerprint",
      "signature": "[tier1] (Env, Any) -> Effect<SemanticKey>",
      "description": "CPO.semantic_fingerprint — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.SemanticKey"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (semantic_fingerprint env ...)\n  (effect semantic_fingerprint ...))"
    },
    {
      "name": "CPO.cache_get",
      "signature": "[tier0] SemanticKey -> Effect<Maybe<CacheEntry>>",
      "description": "CPO.cache_get — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.CacheEntry"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (cache_get env ...)\n  (effect cache_get ...))"
    },
    {
      "name": "CPO.cache_put",
      "signature": "[tier0] CacheEntry -> Effect<Unit>",
      "description": "CPO.cache_put — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.CacheEntry"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (cache_put env ...)\n  (effect cache_put ...))"
    },
    {
      "name": "CPO.cache_invalidate",
      "signature": "[tier0] (Env, URI|SnapshotRef) -> Effect<Unit>",
      "description": "CPO.cache_invalidate — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (cache_invalidate env ...)\n  (effect cache_invalidate ...))"
    },
    {
      "name": "CPO.budget_guard",
      "signature": "[tier0] (Env, Budget, Effect<T>) -> Effect<T>",
      "description": "CPO.budget_guard — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (budget_guard env ...)\n  (effect budget_guard ...))"
    },
    {
      "name": "CPO.redact",
      "signature": "[tier0] (Env, Any, Policy) -> Effect<Any>",
      "description": "CPO.redact — cognitive primitive with explicit contracts, MNF normalization, provenance, and budget discipline.",
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "normalization": [
        "Normalize all textual inputs into MNF.Text with stable Unicode NFC and explicit language tag.",
        "Normalize all artifact references into (uri, snapshot_id, span/row/clause ids) instead of raw excerpts."
      ],
      "failure_modes": [
        "Contract violation (malformed or out-of-domain output).",
        "Budget exhaustion.",
        "Stale snapshot / invalid evidence reference."
      ],
      "mitigations": [
        "Schema coercion + enum coercion with rejection on mismatch.",
        "Tiered execution: deterministic view first; infer only when needed.",
        "Use SnapshotRef + hash to validate evidence; invalidate caches on change events."
      ],
      "omega_pseudocode": "(define (redact env ...)\n  (effect redact ...))"
    }
  ],
  "ca_library": [
    {
      "name": "CA.search.generate_and_test",
      "category": "search",
      "description": "CA.search.generate_and_test — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.judge",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "score/judge candidate hypotheses"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (generate_and_test env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.beam_search",
      "category": "search",
      "description": "CA.search.beam_search — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.judge",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "score/judge candidate hypotheses"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (beam_search env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.best_first",
      "category": "search",
      "description": "CA.search.best_first — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.judge",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "score/judge candidate hypotheses"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (best_first env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.branch_and_bound",
      "category": "search",
      "description": "CA.search.branch_and_bound — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (branch_and_bound env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.amb_backtracking",
      "category": "search",
      "description": "CA.search.amb_backtracking — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.judge",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "score/judge candidate hypotheses"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (amb_backtracking env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.branch_prune",
      "category": "search",
      "description": "CA.search.branch_prune — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (branch_prune env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.search.topk_sampling",
      "category": "search",
      "description": "CA.search.topk_sampling — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.judge",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.Claim"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "score/judge candidate hypotheses"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (topk_sampling env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.constraints.propagator_fixpoint",
      "category": "constraints",
      "description": "CA.constraints.propagator_fixpoint — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (propagator_fixpoint env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "aggregator",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.constraints.contradiction_detection",
      "category": "constraints",
      "description": "CA.constraints.contradiction_detection — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (contradiction_detection env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "aggregator",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.constraints.greedy_unsat_core",
      "category": "constraints",
      "description": "CA.constraints.greedy_unsat_core — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (greedy_unsat_core env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "aggregator",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.constraints.specification_checking",
      "category": "constraints",
      "description": "CA.constraints.specification_checking — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.check_constraints",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ConstraintViolation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "verify invariants and emit violations"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (specification_checking env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "aggregator",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.constraints.policy_consistency",
      "category": "constraints",
      "description": "CA.constraints.policy_consistency — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.check_constraints",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Code.ConstraintViolation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "verify invariants and emit violations"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (policy_consistency env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "aggregator",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.normalization.meaning_normal_form",
      "category": "normalization",
      "description": "CA.normalization.meaning_normal_form — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.normalize",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SemanticKey"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "canonicalize values for stable caching"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (meaning_normal_form env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.normalization.idempotent_canonicalization",
      "category": "normalization",
      "description": "CA.normalization.idempotent_canonicalization — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.normalize",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SemanticKey"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "canonicalize values for stable caching"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (idempotent_canonicalization env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.normalization.bidirectional_entailment",
      "category": "normalization",
      "description": "CA.normalization.bidirectional_entailment — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (bidirectional_entailment env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.normalization.self_consistency_voting",
      "category": "normalization",
      "description": "CA.normalization.self_consistency_voting — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (self_consistency_voting env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.normalization.consensus_merge",
      "category": "normalization",
      "description": "CA.normalization.consensus_merge — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (consensus_merge env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.planning.htn_synthesis",
      "category": "planning",
      "description": "CA.planning.htn_synthesis — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (htn_synthesis env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "router",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.planning.pre_post_guard",
      "category": "planning",
      "description": "CA.planning.pre_post_guard — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (pre_post_guard env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "router",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.planning.saga_compensation",
      "category": "planning",
      "description": "CA.planning.saga_compensation — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (saga_compensation env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "router",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.planning.idempotent_command_plan",
      "category": "planning",
      "description": "CA.planning.idempotent_command_plan — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.normalize",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.SemanticKey"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "canonicalize values for stable caching"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (idempotent_command_plan env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "router",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.nl_to_omega_ir",
      "category": "compilation",
      "description": "CA.compilation.nl_to_omega_ir — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.plan",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Plan.OmegaIR"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "compile NL -> OmegaIR under contract"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (nl_to_omega_ir env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.omega_ir_typecheck",
      "category": "compilation",
      "description": "CA.compilation.omega_ir_typecheck — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (omega_ir_typecheck env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.cost_based_planner",
      "category": "compilation",
      "description": "CA.compilation.cost_based_planner — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (cost_based_planner env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.applicative_batching",
      "category": "compilation",
      "description": "CA.compilation.applicative_batching — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (applicative_batching env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.cse",
      "category": "compilation",
      "description": "CA.compilation.cse — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (cse env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.dce",
      "category": "compilation",
      "description": "CA.compilation.dce — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (dce env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.partial_evaluation",
      "category": "compilation",
      "description": "CA.compilation.partial_evaluation — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (partial_evaluation env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.compilation.lower_to_bytecode",
      "category": "compilation",
      "description": "CA.compilation.lower_to_bytecode — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (lower_to_bytecode env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.cognitive_vm_execute",
      "category": "machine",
      "description": "CA.machine.cognitive_vm_execute — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (cognitive_vm_execute env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.streaming_scatter_gather",
      "category": "machine",
      "description": "CA.machine.streaming_scatter_gather — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.route",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Core.TagSet"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "route question to capable nodes"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (streaming_scatter_gather env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.backpressure_executor",
      "category": "machine",
      "description": "CA.machine.backpressure_executor — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (backpressure_executor env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.rate_limited_executor",
      "category": "machine",
      "description": "CA.machine.rate_limited_executor — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (rate_limited_executor env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.resequencer_ordering",
      "category": "machine",
      "description": "CA.machine.resequencer_ordering — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (resequencer_ordering env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "resequencer",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.provenance.provenance_dag_build",
      "category": "provenance",
      "description": "CA.provenance.provenance_dag_build — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (provenance_dag_build env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "claim-check",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.provenance.provenance_minimization",
      "category": "provenance",
      "description": "CA.provenance.provenance_minimization — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (provenance_minimization env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "claim-check",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.provenance.receipt_replay",
      "category": "provenance",
      "description": "CA.provenance.receipt_replay — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (receipt_replay env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "claim-check",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.provenance.evidence_weaving",
      "category": "provenance",
      "description": "CA.provenance.evidence_weaving — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.cite",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.Citation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "anchor outputs to evidence"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (evidence_weaving env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "claim-check",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.provenance.citation_synthesis",
      "category": "provenance",
      "description": "CA.provenance.citation_synthesis — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.cite",
          "contract": {
            "kind": "schema",
            "payload": {
              "type": "object",
              "properties": {
                "_type": {
                  "const": "CDT.Evidence.Citation"
                }
              },
              "required": [
                "_type"
              ]
            }
          },
          "purpose": "anchor outputs to evidence"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (citation_synthesis env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "claim-check",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.caching.semantic_memoization",
      "category": "caching",
      "description": "CA.caching.semantic_memoization — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (semantic_memoization env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.caching.similarity_cache_with_validation",
      "category": "caching",
      "description": "CA.caching.similarity_cache_with_validation — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (similarity_cache_with_validation env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.caching.materialized_view_refresh",
      "category": "caching",
      "description": "CA.caching.materialized_view_refresh — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (materialized_view_refresh env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.caching.snapshot_invalidation",
      "category": "caching",
      "description": "CA.caching.snapshot_invalidation — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (snapshot_invalidation env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.concurrency.optimistic_concurrency",
      "category": "concurrency",
      "description": "CA.concurrency.optimistic_concurrency — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (optimistic_concurrency env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.concurrency.bulkhead_isolation",
      "category": "concurrency",
      "description": "CA.concurrency.bulkhead_isolation — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (bulkhead_isolation env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.concurrency.retry_with_jitter",
      "category": "concurrency",
      "description": "CA.concurrency.retry_with_jitter — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (retry_with_jitter env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.concurrency.serializer",
      "category": "concurrency",
      "description": "CA.concurrency.serializer — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (serializer env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.golden_master_harness",
      "category": "machine",
      "description": "CA.machine.golden_master_harness — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.golden_master_compare",
          "contract": {
            "kind": "enum",
            "payload": {
              "enum": [
                "pass",
                "fail"
              ]
            }
          },
          "purpose": "compare structured outputs to snapshot goldens"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (golden_master_harness env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.metamorphic_test_harness",
      "category": "machine",
      "description": "CA.machine.metamorphic_test_harness — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.metamorphic_check",
          "contract": {
            "kind": "enum",
            "payload": {
              "enum": [
                "pass",
                "fail"
              ]
            }
          },
          "purpose": "check invariances under transformations"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (metamorphic_test_harness env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    },
    {
      "name": "CA.machine.contract_test_harness",
      "category": "machine",
      "description": "CA.machine.contract_test_harness — deterministic skeleton interleaving compute with typed cognitive effects.",
      "deterministic_skeleton": [
        "Establish Budget and SnapshotRef boundaries.",
        "Execute deterministic control structure; call inference only at declared decision points.",
        "Emit Receipt + ProvenanceNode for each effect; enforce contracts.",
        "Return MNF-normalized CDT outputs."
      ],
      "uses_inference": [
        {
          "cpo": "CPO.coerce_schema",
          "contract": {
            "kind": "enum",
            "payload": {
              "enum": [
                "pass",
                "fail"
              ]
            }
          },
          "purpose": "validate effect outputs against schema"
        }
      ],
      "complexity_model": {
        "calls": "O(k) effect calls; bounded by Budget.calls",
        "tokens": "Dominated by infer.op; bounded by Budget.tokens",
        "latency": "Parallelizable over Matrix subtree; bounded by max_parallel + node RTT"
      },
      "failure_modes": [
        "Budget exhaustion (tokens/calls/time).",
        "Contract violation from effect output.",
        "Non-convergence / combinatorial blow-up."
      ],
      "mitigations": [
        "Stage cheap deterministic filters before infer.op; cap depth/beam.",
        "Use schema coercion + enum coercion adapters; reject invalid outputs.",
        "Cache via SemanticKey; apply backpressure + rate limits."
      ],
      "omega_pseudocode": "(define (contract_test_harness env inputs)\n  ;; skeleton\n  (budget-guard env (lambda () ...)))",
      "matrix_distribution": {
        "pattern": "scatter-gather",
        "notes": "Exploit hierarchical nodes with bounded parallelism; stream partial results."
      }
    }
  ],
  "pattern_mappings": [
    {
      "family": "fp",
      "pattern_name": "fp.FunctorMap",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.View.EvidenceView"
        ],
        "cpos": [
          "CPO.route",
          "CPO.query",
          "CPO.aggregate"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather",
          "CA.normalization.consensus_merge"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-FunctorMap env uri)\n  ;; FunctorMap\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "scatter-gather"
      },
      "example_use_cases": [
        "Use FunctorMap to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.ApplicativeBatching",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Budget"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.optimize_ir",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.compilation.applicative_batching",
          "CA.compilation.cost_based_planner"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-ApplicativeBatching env uri)\n  ;; ApplicativeBatching\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "batched execution"
      },
      "example_use_cases": [
        "Use ApplicativeBatching to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.MonadKleisli",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Plan.OmegaIR",
          "CDT.Plan.QueryPlan",
          "CDT.Core.Answer"
        ],
        "cpos": [
          "CPO.plan",
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.compilation.nl_to_omega_ir",
          "CA.compilation.lower_to_bytecode",
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-MonadKleisli env uri)\n  ;; MonadKleisli\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "Kleisli composition"
      },
      "example_use_cases": [
        "Use MonadKleisli to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.FoldReduce",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Answer",
          "CDT.Core.TagSet"
        ],
        "cpos": [
          "CPO.aggregate",
          "CPO.consensus"
        ],
        "cas": [
          "CA.normalization.consensus_merge",
          "CA.normalization.self_consistency_voting"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-FoldReduce env uri)\n  ;; FoldReduce\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "reduce"
      },
      "example_use_cases": [
        "Use FoldReduce to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.MonoidAggregation",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Answer",
          "CDT.Core.TagSet"
        ],
        "cpos": [
          "CPO.aggregate",
          "CPO.consensus"
        ],
        "cas": [
          "CA.normalization.consensus_merge",
          "CA.normalization.self_consistency_voting"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-MonoidAggregation env uri)\n  ;; MonoidAggregation\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "reduce"
      },
      "example_use_cases": [
        "Use MonoidAggregation to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Streams",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.TimelineView",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.resequence",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.backpressure_executor",
          "CA.machine.resequencer_ordering"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (fp-Streams env uri)\n  ;; Streams\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "streaming"
      },
      "example_use_cases": [
        "Use Streams to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.LazyEvaluation",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.TimelineView",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.resequence",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.backpressure_executor",
          "CA.machine.resequencer_ordering"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (fp-LazyEvaluation env uri)\n  ;; LazyEvaluation\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "streaming"
      },
      "example_use_cases": [
        "Use LazyEvaluation to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.ParserCombinators",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.OmegaIR",
          "CDT.Core.SemanticContract"
        ],
        "cpos": [
          "CPO.plan",
          "CPO.coerce_schema"
        ],
        "cas": [
          "CA.compilation.nl_to_omega_ir",
          "CA.compilation.omega_ir_typecheck"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-ParserCombinators env uri)\n  ;; ParserCombinators\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "compilation"
      },
      "example_use_cases": [
        "Use ParserCombinators to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Lenses",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.ASTView",
          "CDT.Code.Patch"
        ],
        "cpos": [
          "CPO.extract",
          "CPO.generate_patch",
          "CPO.apply_patch"
        ],
        "cas": [
          "CA.compilation.partial_evaluation",
          "CA.concurrency.optimistic_concurrency"
        ],
        "matrix_views": [
          "ASTView"
        ]
      },
      "omega_skeleton": "(define (fp-Lenses env uri)\n  ;; Lenses\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "local rewrite"
      },
      "example_use_cases": [
        "Use Lenses to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Zippers",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.ASTView",
          "CDT.Code.Patch"
        ],
        "cpos": [
          "CPO.extract",
          "CPO.generate_patch",
          "CPO.apply_patch"
        ],
        "cas": [
          "CA.compilation.partial_evaluation",
          "CA.concurrency.optimistic_concurrency"
        ],
        "matrix_views": [
          "ASTView"
        ]
      },
      "omega_skeleton": "(define (fp-Zippers env uri)\n  ;; Zippers\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "local rewrite"
      },
      "example_use_cases": [
        "Use Zippers to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.FixedPoint",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.ConstraintNetwork",
          "CDT.Code.ConstraintViolation"
        ],
        "cpos": [
          "CPO.propagate_constraints",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint",
          "CA.constraints.contradiction_detection"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-FixedPoint env uri)\n  ;; FixedPoint\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "fixpoint"
      },
      "example_use_cases": [
        "Use FixedPoint to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Memoization",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SemanticKey",
          "CDT.Core.CacheEntry"
        ],
        "cpos": [
          "CPO.semantic_fingerprint",
          "CPO.cache_get",
          "CPO.cache_put"
        ],
        "cas": [
          "CA.caching.semantic_memoization",
          "CA.caching.snapshot_invalidation"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-Memoization env uri)\n  ;; Memoization\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "memoize"
      },
      "example_use_cases": [
        "Use Memoization to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.FreeMonad",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.OmegaIR",
          "CDT.Plan.Bytecode"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.compilation.lower_to_bytecode",
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-FreeMonad env uri)\n  ;; FreeMonad\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "interpret"
      },
      "example_use_cases": [
        "Use FreeMonad to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.EitherError",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.ErrorReport",
          "CDT.Core.SchemaSpec"
        ],
        "cpos": [
          "CPO.coerce_schema",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking",
          "CA.constraints.greedy_unsat_core"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-EitherError env uri)\n  ;; EitherError\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "validate"
      },
      "example_use_cases": [
        "Use EitherError to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.ValidatedApplicative",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.ErrorReport",
          "CDT.Core.SchemaSpec"
        ],
        "cpos": [
          "CPO.coerce_schema",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking",
          "CA.constraints.greedy_unsat_core"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (fp-ValidatedApplicative env uri)\n  ;; ValidatedApplicative\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "validate"
      },
      "example_use_cases": [
        "Use ValidatedApplicative to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Arrows",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Core.SemanticKey",
          "CDT.Core.Answer",
          "CDT.Plan.OmegaIR"
        ],
        "cpos": [
          "CPO.normalize",
          "CPO.semantic_fingerprint",
          "CPO.cache_get",
          "CPO.cache_put",
          "CPO.plan"
        ],
        "cas": [
          "CA.normalization.meaning_normal_form",
          "CA.caching.semantic_memoization",
          "CA.compilation.nl_to_omega_ir"
        ],
        "matrix_views": [
          "EvidenceView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-Arrows env uri)\n  ;; Arrows\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "Kleisli composition"
      },
      "example_use_cases": [
        "Use Arrows to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Continuation",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.emit_provenance",
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build",
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-Continuation env uri)\n  ;; Continuation\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "replayable effects"
      },
      "example_use_cases": [
        "Use Continuation to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.Trampoline",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.emit_provenance",
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build",
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-Trampoline env uri)\n  ;; Trampoline\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "replayable effects"
      },
      "example_use_cases": [
        "Use Trampoline to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.ReaderEnv",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.emit_provenance",
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build",
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-ReaderEnv env uri)\n  ;; ReaderEnv\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "replayable effects"
      },
      "example_use_cases": [
        "Use ReaderEnv to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.WriterLog",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.emit_provenance",
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build",
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-WriterLog env uri)\n  ;; WriterLog\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "replayable effects"
      },
      "example_use_cases": [
        "Use WriterLog to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.StateThread",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.emit_provenance",
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build",
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-StateThread env uri)\n  ;; StateThread\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "replayable effects"
      },
      "example_use_cases": [
        "Use StateThread to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.RefinementTypes",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Core.SemanticKey",
          "CDT.Core.Answer",
          "CDT.Plan.OmegaIR"
        ],
        "cpos": [
          "CPO.normalize",
          "CPO.semantic_fingerprint",
          "CPO.cache_get",
          "CPO.cache_put",
          "CPO.plan"
        ],
        "cas": [
          "CA.normalization.meaning_normal_form",
          "CA.caching.semantic_memoization",
          "CA.compilation.nl_to_omega_ir"
        ],
        "matrix_views": [
          "EvidenceView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-RefinementTypes env uri)\n  ;; RefinementTypes\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "Kleisli composition"
      },
      "example_use_cases": [
        "Use RefinementTypes to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.AlgebraicEffects",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.OmegaIR",
          "CDT.Plan.Bytecode"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.compilation.lower_to_bytecode",
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-AlgebraicEffects env uri)\n  ;; AlgebraicEffects\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "interpret"
      },
      "example_use_cases": [
        "Use AlgebraicEffects to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.EffectHandlers",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.OmegaIR",
          "CDT.Plan.Bytecode"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.compilation.lower_to_bytecode",
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-EffectHandlers env uri)\n  ;; EffectHandlers\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "interpret"
      },
      "example_use_cases": [
        "Use EffectHandlers to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "fp",
      "pattern_name": "fp.RecursionSchemes",
      "classical_definition": "A compositional abstraction in functional programming for structuring computation.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Env",
          "CDT.Core.SemanticKey",
          "CDT.Core.Answer",
          "CDT.Plan.OmegaIR"
        ],
        "cpos": [
          "CPO.normalize",
          "CPO.semantic_fingerprint",
          "CPO.cache_get",
          "CPO.cache_put",
          "CPO.plan"
        ],
        "cas": [
          "CA.normalization.meaning_normal_form",
          "CA.caching.semantic_memoization",
          "CA.compilation.nl_to_omega_ir"
        ],
        "matrix_views": [
          "EvidenceView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (fp-RecursionSchemes env uri)\n  ;; RecursionSchemes\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "Kleisli composition"
      },
      "example_use_cases": [
        "Use RecursionSchemes to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.ContentBasedRouter",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.TagSet",
          "CDT.Core.Question"
        ],
        "cpos": [
          "CPO.route",
          "CPO.classify"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-ContentBasedRouter env uri)\n  ;; ContentBasedRouter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "content-based routing"
      },
      "example_use_cases": [
        "Use ContentBasedRouter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.MessageTranslator",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SchemaSpec",
          "CDT.Core.EnumSpec"
        ],
        "cpos": [
          "CPO.coerce_schema",
          "CPO.coerce_enum",
          "CPO.normalize"
        ],
        "cas": [
          "CA.normalization.meaning_normal_form"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (eip-MessageTranslator env uri)\n  ;; MessageTranslator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "translation"
      },
      "example_use_cases": [
        "Use MessageTranslator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Splitter",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question"
        ],
        "cpos": [
          "CPO.split",
          "CPO.route"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-Splitter env uri)\n  ;; Splitter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "split+route"
      },
      "example_use_cases": [
        "Use Splitter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Aggregator",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Answer"
        ],
        "cpos": [
          "CPO.aggregate",
          "CPO.consensus"
        ],
        "cas": [
          "CA.normalization.consensus_merge"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (eip-Aggregator env uri)\n  ;; Aggregator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "aggregate"
      },
      "example_use_cases": [
        "Use Aggregator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Resequencer",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.TimelineView"
        ],
        "cpos": [
          "CPO.resequence"
        ],
        "cas": [
          "CA.machine.resequencer_ordering"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-Resequencer env uri)\n  ;; Resequencer\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "resequencing"
      },
      "example_use_cases": [
        "Use Resequencer to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.ClaimCheck",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.CacheEntry",
          "CDT.Core.SemanticKey"
        ],
        "cpos": [
          "CPO.cache_put",
          "CPO.cache_get",
          "CPO.semantic_fingerprint"
        ],
        "cas": [
          "CA.caching.semantic_memoization"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (eip-ClaimCheck env uri)\n  ;; ClaimCheck\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "claim-check"
      },
      "example_use_cases": [
        "Use ClaimCheck to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.IdempotentReceiver",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.planning.idempotent_command_plan"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-IdempotentReceiver env uri)\n  ;; IdempotentReceiver\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "idempotency"
      },
      "example_use_cases": [
        "Use IdempotentReceiver to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Saga",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.command",
          "CPO.rollback_patch"
        ],
        "cas": [
          "CA.planning.saga_compensation"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-Saga env uri)\n  ;; Saga\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "saga/compensation"
      },
      "example_use_cases": [
        "Use Saga to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.PublishSubscribe",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.publish_event"
        ],
        "cas": [
          "CA.machine.backpressure_executor"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-PublishSubscribe env uri)\n  ;; PublishSubscribe\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "pub-sub"
      },
      "example_use_cases": [
        "Use PublishSubscribe to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.ScatterGather",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer"
        ],
        "cpos": [
          "CPO.route",
          "CPO.query",
          "CPO.aggregate"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-ScatterGather env uri)\n  ;; ScatterGather\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "scatter-gather"
      },
      "example_use_cases": [
        "Use ScatterGather to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.WireTap",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.AuditTrail"
        ],
        "cpos": [
          "CPO.publish_event",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-WireTap env uri)\n  ;; WireTap\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "wire-tap"
      },
      "example_use_cases": [
        "Use WireTap to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.MessageStore",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.AuditTrail",
          "CDT.Core.CacheEntry"
        ],
        "cpos": [
          "CPO.cache_put",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.caching.snapshot_invalidation"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (eip-MessageStore env uri)\n  ;; MessageStore\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "store"
      },
      "example_use_cases": [
        "Use MessageStore to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.ContentEnricher",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Evidence.EvidenceSet",
          "CDT.Core.Summary"
        ],
        "cpos": [
          "CPO.extract",
          "CPO.summarize",
          "CPO.cite"
        ],
        "cas": [
          "CA.provenance.evidence_weaving"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (eip-ContentEnricher env uri)\n  ;; ContentEnricher\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "enrich"
      },
      "example_use_cases": [
        "Use ContentEnricher to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.MessageFilter",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-MessageFilter env uri)\n  ;; MessageFilter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use MessageFilter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.DeadLetterChannel",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.AuditTrail",
          "CDT.Core.ErrorReport"
        ],
        "cpos": [
          "CPO.record_receipt",
          "CPO.emit_provenance"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-DeadLetterChannel env uri)\n  ;; DeadLetterChannel\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "dead-letter"
      },
      "example_use_cases": [
        "Use DeadLetterChannel to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Retry",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.command",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.concurrency.retry_with_jitter"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (eip-Retry env uri)\n  ;; Retry\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "retry"
      },
      "example_use_cases": [
        "Use Retry to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.CircuitBreaker",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy"
        ],
        "cpos": [
          "CPO.command",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.concurrency.bulkhead_isolation"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-CircuitBreaker env uri)\n  ;; CircuitBreaker\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "bulkhead/circuit"
      },
      "example_use_cases": [
        "Use CircuitBreaker to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.CorrelationIdentifier",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.record_receipt",
          "CPO.emit_provenance"
        ],
        "cas": [
          "CA.provenance.provenance_dag_build"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-CorrelationIdentifier env uri)\n  ;; CorrelationIdentifier\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "correlate"
      },
      "example_use_cases": [
        "Use CorrelationIdentifier to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.MessageEndpoint",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-MessageEndpoint env uri)\n  ;; MessageEndpoint\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use MessageEndpoint to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.CompetingConsumers",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-CompetingConsumers env uri)\n  ;; CompetingConsumers\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use CompetingConsumers to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.MessageBridge",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-MessageBridge env uri)\n  ;; MessageBridge\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use MessageBridge to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.Normalizer",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-Normalizer env uri)\n  ;; Normalizer\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use Normalizer to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.RoutingSlip",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-RoutingSlip env uri)\n  ;; RoutingSlip\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use RoutingSlip to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.RecipientList",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-RecipientList env uri)\n  ;; RecipientList\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use RecipientList to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "eip",
      "pattern_name": "eip.ChannelAdapter",
      "classical_definition": "A message-based integration pattern for routing/transformation/coordination.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.route",
          "CPO.aggregate",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (eip-ChannelAdapter env uri)\n  ;; ChannelAdapter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "message flow"
      },
      "example_use_cases": [
        "Use ChannelAdapter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Strategy",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate",
          "CPO.rank"
        ],
        "cas": [
          "CA.normalization.self_consistency_voting"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Strategy env uri)\n  ;; Strategy\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "policy-driven"
      },
      "example_use_cases": [
        "Use Strategy to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Command",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.command",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.planning.idempotent_command_plan"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (gof-Command env uri)\n  ;; Command\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "commands+receipts"
      },
      "example_use_cases": [
        "Use Command to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Observer",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.publish_event"
        ],
        "cas": [
          "CA.machine.backpressure_executor"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (gof-Observer env uri)\n  ;; Observer\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "event-driven"
      },
      "example_use_cases": [
        "Use Observer to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Mediator",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.planning.pre_post_guard"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Mediator env uri)\n  ;; Mediator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "orchestrate"
      },
      "example_use_cases": [
        "Use Mediator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.ChainOfResponsibility",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Question",
          "CDT.Core.Answer"
        ],
        "cpos": [
          "CPO.route",
          "CPO.query"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-ChainOfResponsibility env uri)\n  ;; ChainOfResponsibility\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "chain routing"
      },
      "example_use_cases": [
        "Use ChainOfResponsibility to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Composite",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.GraphView"
        ],
        "cpos": [
          "CPO.view",
          "CPO.aggregate"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Composite env uri)\n  ;; Composite\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "composite tree"
      },
      "example_use_cases": [
        "Use Composite to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Visitor",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.ASTView",
          "CDT.Evidence.EvidenceSet"
        ],
        "cpos": [
          "CPO.extract"
        ],
        "cas": [
          "CA.compilation.cse"
        ],
        "matrix_views": [
          "ASTView"
        ]
      },
      "omega_skeleton": "(define (gof-Visitor env uri)\n  ;; Visitor\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "structured traversal"
      },
      "example_use_cases": [
        "Use Visitor to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Adapter",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SchemaSpec"
        ],
        "cpos": [
          "CPO.coerce_schema",
          "CPO.normalize"
        ],
        "cas": [
          "CA.normalization.idempotent_canonicalization"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Adapter env uri)\n  ;; Adapter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "shape adaptation"
      },
      "example_use_cases": [
        "Use Adapter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Facade",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.EvidenceView",
          "CDT.Core.Summary"
        ],
        "cpos": [
          "CPO.summarize"
        ],
        "cas": [
          "CA.normalization.consensus_merge"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Facade env uri)\n  ;; Facade\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "simplify interface"
      },
      "example_use_cases": [
        "Use Facade to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Proxy",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.CacheEntry",
          "CDT.Core.SemanticKey"
        ],
        "cpos": [
          "CPO.cache_get",
          "CPO.cache_put"
        ],
        "cas": [
          "CA.caching.similarity_cache_with_validation"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Proxy env uri)\n  ;; Proxy\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "proxy cache"
      },
      "example_use_cases": [
        "Use Proxy to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Decorator",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy"
        ],
        "cpos": [
          "CPO.redact",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Decorator env uri)\n  ;; Decorator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "policy decorator"
      },
      "example_use_cases": [
        "Use Decorator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Interpreter",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.OmegaIR",
          "CDT.Plan.Bytecode"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Interpreter env uri)\n  ;; Interpreter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "interpret IR"
      },
      "example_use_cases": [
        "Use Interpreter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Builder",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.optimize_ir"
        ],
        "cas": [
          "CA.compilation.cost_based_planner"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Builder env uri)\n  ;; Builder\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "build plan"
      },
      "example_use_cases": [
        "Use Builder to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.AbstractFactory",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.generate_alternatives",
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.beam_search"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-AbstractFactory env uri)\n  ;; AbstractFactory\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "generate family"
      },
      "example_use_cases": [
        "Use AbstractFactory to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Prototype",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Prototype env uri)\n  ;; Prototype\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Prototype to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.TemplateMethod",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.SemanticContract"
        ],
        "cpos": [
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-TemplateMethod env uri)\n  ;; TemplateMethod\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "fixed skeleton"
      },
      "example_use_cases": [
        "Use TemplateMethod to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.State",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.StateMachineView",
          "CDT.IoT.DeviceState"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking"
        ],
        "matrix_views": [
          "StateMachineView"
        ]
      },
      "omega_skeleton": "(define (gof-State env uri)\n  ;; State\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "explicit states"
      },
      "example_use_cases": [
        "Use State to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Singleton",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Singleton env uri)\n  ;; Singleton\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Singleton to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Flyweight",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Flyweight env uri)\n  ;; Flyweight\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Flyweight to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Bridge",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Bridge env uri)\n  ;; Bridge\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Bridge to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.FactoryMethod",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-FactoryMethod env uri)\n  ;; FactoryMethod\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use FactoryMethod to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Iterator",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Iterator env uri)\n  ;; Iterator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Iterator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Memento",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SnapshotRef"
        ],
        "cpos": [
          "CPO.snapshot",
          "CPO.cache_invalidate"
        ],
        "cas": [
          "CA.caching.snapshot_invalidation"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (gof-Memento env uri)\n  ;; Memento\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "snapshotting"
      },
      "example_use_cases": [
        "Use Memento to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.NullObject",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-NullObject env uri)\n  ;; NullObject\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use NullObject to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.ObjectPool",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-ObjectPool env uri)\n  ;; ObjectPool\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use ObjectPool to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.ServiceLocator",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-ServiceLocator env uri)\n  ;; ServiceLocator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use ServiceLocator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.Specification",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-Specification env uri)\n  ;; Specification\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use Specification to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.FacadeToLegacy",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-FacadeToLegacy env uri)\n  ;; FacadeToLegacy\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use FacadeToLegacy to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.ProxyCache",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-ProxyCache env uri)\n  ;; ProxyCache\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use ProxyCache to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.DecoratorPolicy",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-DecoratorPolicy env uri)\n  ;; DecoratorPolicy\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use DecoratorPolicy to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.VisitorExtraction",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-VisitorExtraction env uri)\n  ;; VisitorExtraction\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use VisitorExtraction to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.CompositeView",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-CompositeView env uri)\n  ;; CompositeView\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use CompositeView to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.MediatorOrchestrator",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-MediatorOrchestrator env uri)\n  ;; MediatorOrchestrator\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use MediatorOrchestrator to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.ChainRouter",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-ChainRouter env uri)\n  ;; ChainRouter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use ChainRouter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "gof",
      "pattern_name": "gof.BuilderPlan",
      "classical_definition": "A reusable object collaboration structure capturing intent, participants, and consequences.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Core.Decision"
        ],
        "cpos": [
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.best_first"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (gof-BuilderPlan env uri)\n  ;; BuilderPlan\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "CommandPort",
          "QueryPort"
        ],
        "distribution": "object collaboration"
      },
      "example_use_cases": [
        "Use BuilderPlan to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Aggregate",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.URI",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints",
          "CPO.propagate_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Aggregate env uri)\n  ;; Aggregate\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "aggregate invariants"
      },
      "example_use_cases": [
        "Use Aggregate to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Repository",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.RelationalView",
          "CDT.Data.QueryResultSet"
        ],
        "cpos": [
          "CPO.query",
          "CPO.view"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "RelationalView"
        ]
      },
      "omega_skeleton": "(define (ddd-Repository env uri)\n  ;; Repository\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "repository queries"
      },
      "example_use_cases": [
        "Use Repository to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.DomainEvent",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent",
          "CDT.Provenance.AuditTrail"
        ],
        "cpos": [
          "CPO.publish_event",
          "CPO.subscribe_events"
        ],
        "cas": [
          "CA.machine.backpressure_executor"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ddd-DomainEvent env uri)\n  ;; DomainEvent\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain events"
      },
      "example_use_cases": [
        "Use DomainEvent to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.BoundedContext",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.URI",
          "CDT.Core.Policy"
        ],
        "cpos": [
          "CPO.route"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-BoundedContext env uri)\n  ;; BoundedContext\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "namespace boundaries"
      },
      "example_use_cases": [
        "Use BoundedContext to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.ContextMap",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-ContextMap env uri)\n  ;; ContextMap\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use ContextMap to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.AntiCorruptionLayer",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SchemaSpec",
          "CDT.Core.EnumSpec"
        ],
        "cpos": [
          "CPO.coerce_schema",
          "CPO.coerce_enum"
        ],
        "cas": [
          "CA.normalization.meaning_normal_form"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ddd-AntiCorruptionLayer env uri)\n  ;; AntiCorruptionLayer\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "ACL translation"
      },
      "example_use_cases": [
        "Use AntiCorruptionLayer to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.CQRS",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.RelationalView",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.query",
          "CPO.command"
        ],
        "cas": [
          "CA.planning.pre_post_guard"
        ],
        "matrix_views": [
          "RelationalView",
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ddd-CQRS env uri)\n  ;; CQRS\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "separate read/write"
      },
      "example_use_cases": [
        "Use CQRS to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.EventSourcing",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.ProvenanceDAG",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.record_receipt",
          "CPO.replay_receipt"
        ],
        "cas": [
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-EventSourcing env uri)\n  ;; EventSourcing\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "event sourcing"
      },
      "example_use_cases": [
        "Use EventSourcing to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.ValueObject",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-ValueObject env uri)\n  ;; ValueObject\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use ValueObject to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Entity",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Entity env uri)\n  ;; Entity\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use Entity to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Factory",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Factory env uri)\n  ;; Factory\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use Factory to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Service",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Service env uri)\n  ;; Service\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use Service to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Specification",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Specification env uri)\n  ;; Specification\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use Specification to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.UbiquitousLanguage",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-UbiquitousLanguage env uri)\n  ;; UbiquitousLanguage\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use UbiquitousLanguage to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.ApplicationService",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-ApplicationService env uri)\n  ;; ApplicationService\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use ApplicationService to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.SagaProcessManager",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-SagaProcessManager env uri)\n  ;; SagaProcessManager\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use SagaProcessManager to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Outbox",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-Outbox env uri)\n  ;; Outbox\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use Outbox to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.UnitOfWork",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Code.ConstraintNetwork"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.propagator_fixpoint"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (ddd-UnitOfWork env uri)\n  ;; UnitOfWork\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "domain model"
      },
      "example_use_cases": [
        "Use UnitOfWork to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.Invariant",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.ConstraintViolation"
        ],
        "cpos": [
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ddd-Invariant env uri)\n  ;; Invariant\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "invariants"
      },
      "example_use_cases": [
        "Use Invariant to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ddd",
      "pattern_name": "ddd.PolicyAsCode",
      "classical_definition": "A domain modeling pattern for consistency boundaries, persistence, and ubiquitous language.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.Policy",
          "CDT.Legal.AccessControlRule"
        ],
        "cpos": [
          "CPO.check_constraints",
          "CPO.redact"
        ],
        "cas": [
          "CA.constraints.policy_consistency"
        ],
        "matrix_views": [
          "ClauseView"
        ]
      },
      "omega_skeleton": "(define (ddd-PolicyAsCode env uri)\n  ;; PolicyAsCode\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "policy"
      },
      "example_use_cases": [
        "Use PolicyAsCode to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Layers",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.APIView",
          "CDT.View.ConfigView",
          "CDT.Plan.QueryPlan"
        ],
        "cpos": [
          "CPO.view",
          "CPO.compile"
        ],
        "cas": [
          "CA.compilation.cost_based_planner"
        ],
        "matrix_views": [
          "APIView",
          "ConfigView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-Layers env uri)\n  ;; Layers\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "layered"
      },
      "example_use_cases": [
        "Use Layers to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.PipesAndFilters",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SemanticContract",
          "CDT.Plan.OmegaIR"
        ],
        "cpos": [
          "CPO.plan",
          "CPO.optimize_ir"
        ],
        "cas": [
          "CA.compilation.cse",
          "CA.compilation.dce"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-PipesAndFilters env uri)\n  ;; PipesAndFilters\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "typed filters"
      },
      "example_use_cases": [
        "Use PipesAndFilters to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Broker",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.CapabilitySet",
          "CDT.Core.URI"
        ],
        "cpos": [
          "CPO.capabilities",
          "CPO.route"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-Broker env uri)\n  ;; Broker\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "broker"
      },
      "example_use_cases": [
        "Use Broker to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Blackboard",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.EvidenceView",
          "CDT.Provenance.ProvenanceDAG"
        ],
        "cpos": [
          "CPO.aggregate",
          "CPO.emit_provenance"
        ],
        "cas": [
          "CA.provenance.evidence_weaving"
        ],
        "matrix_views": [
          "EvidenceView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-Blackboard env uri)\n  ;; Blackboard\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "blackboard"
      },
      "example_use_cases": [
        "Use Blackboard to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Microkernel",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.CapabilitySet",
          "CDT.Core.Policy"
        ],
        "cpos": [
          "CPO.capabilities",
          "CPO.select_candidate"
        ],
        "cas": [
          "CA.search.beam_search"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-Microkernel env uri)\n  ;; Microkernel\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "plugins"
      },
      "example_use_cases": [
        "Use Microkernel to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Reactor",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.publish_event"
        ],
        "cas": [
          "CA.machine.backpressure_executor"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (posa-Reactor env uri)\n  ;; Reactor\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "reactor"
      },
      "example_use_cases": [
        "Use Reactor to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.HalfSyncHalfAsync",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-HalfSyncHalfAsync env uri)\n  ;; HalfSyncHalfAsync\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use HalfSyncHalfAsync to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.LeaderFollowers",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-LeaderFollowers env uri)\n  ;; LeaderFollowers\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use LeaderFollowers to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.ClientServer",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-ClientServer env uri)\n  ;; ClientServer\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use ClientServer to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.MVC",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-MVC env uri)\n  ;; MVC\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use MVC to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.PAC",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-PAC env uri)\n  ;; PAC\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use PAC to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.PresentationAbstractionControl",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-PresentationAbstractionControl env uri)\n  ;; PresentationAbstractionControl\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use PresentationAbstractionControl to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.ModelViewPresenter",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-ModelViewPresenter env uri)\n  ;; ModelViewPresenter\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use ModelViewPresenter to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.EventDrivenArchitecture",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent"
        ],
        "cpos": [
          "CPO.subscribe_events",
          "CPO.publish_event"
        ],
        "cas": [
          "CA.machine.backpressure_executor"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (posa-EventDrivenArchitecture env uri)\n  ;; EventDrivenArchitecture\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "reactor"
      },
      "example_use_cases": [
        "Use EventDrivenArchitecture to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.Microservices",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.URI",
          "CDT.Provenance.AuditTrail"
        ],
        "cpos": [
          "CPO.route",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.machine.streaming_scatter_gather"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-Microservices env uri)\n  ;; Microservices\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project/src"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "service boundaries"
      },
      "example_use_cases": [
        "Use Microservices to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.ServiceMesh",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-ServiceMesh env uri)\n  ;; ServiceMesh\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use ServiceMesh to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.CQRSArchitecture",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-CQRSArchitecture env uri)\n  ;; CQRSArchitecture\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use CQRSArchitecture to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.HexagonalArchitecture",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.APIView",
          "CDT.View.ConfigView",
          "CDT.Plan.QueryPlan"
        ],
        "cpos": [
          "CPO.view",
          "CPO.compile"
        ],
        "cas": [
          "CA.compilation.cost_based_planner"
        ],
        "matrix_views": [
          "APIView",
          "ConfigView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-HexagonalArchitecture env uri)\n  ;; HexagonalArchitecture\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "layered"
      },
      "example_use_cases": [
        "Use HexagonalArchitecture to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.PortsAndAdapters",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.View.APIView",
          "CDT.View.ConfigView",
          "CDT.Plan.QueryPlan"
        ],
        "cpos": [
          "CPO.view",
          "CPO.compile"
        ],
        "cas": [
          "CA.compilation.cost_based_planner"
        ],
        "matrix_views": [
          "APIView",
          "ConfigView",
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-PortsAndAdapters env uri)\n  ;; PortsAndAdapters\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "layered"
      },
      "example_use_cases": [
        "Use PortsAndAdapters to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "posa",
      "pattern_name": "posa.SpaceBasedArchitecture",
      "classical_definition": "An architectural pattern specifying component topology and interaction style.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.QueryPlan",
          "CDT.Core.Env"
        ],
        "cpos": [
          "CPO.compile",
          "CPO.execute_plan"
        ],
        "cas": [
          "CA.machine.cognitive_vm_execute"
        ],
        "matrix_views": [
          "GraphView"
        ]
      },
      "omega_skeleton": "(define (posa-SpaceBasedArchitecture env uri)\n  ;; SpaceBasedArchitecture\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "QueryPort",
          "ViewPort"
        ],
        "distribution": "architecture"
      },
      "example_use_cases": [
        "Use SpaceBasedArchitecture to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.GoldenMaster",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.ExecutionTrace"
        ],
        "cpos": [
          "CPO.golden_master_record",
          "CPO.golden_master_compare"
        ],
        "cas": [
          "CA.machine.golden_master_harness"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-GoldenMaster env uri)\n  ;; GoldenMaster\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "goldens"
      },
      "example_use_cases": [
        "Use GoldenMaster to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.ContractTests",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SchemaSpec"
        ],
        "cpos": [
          "CPO.coerce_schema"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-ContractTests env uri)\n  ;; ContractTests\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "contracts"
      },
      "example_use_cases": [
        "Use ContractTests to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.MetamorphicTests",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.PropertySpec"
        ],
        "cpos": [
          "CPO.metamorphic_check"
        ],
        "cas": [
          "CA.machine.metamorphic_test_harness"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-MetamorphicTests env uri)\n  ;; MetamorphicTests\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "metamorphic"
      },
      "example_use_cases": [
        "Use MetamorphicTests to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.ReplayReceipts",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Provenance.Receipt",
          "CDT.Provenance.AuditTrail"
        ],
        "cpos": [
          "CPO.replay_receipt",
          "CPO.record_receipt"
        ],
        "cas": [
          "CA.provenance.receipt_replay"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-ReplayReceipts env uri)\n  ;; ReplayReceipts\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "replay"
      },
      "example_use_cases": [
        "Use ReplayReceipts to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.DeterminismHarness",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-DeterminismHarness env uri)\n  ;; DeterminismHarness\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use DeterminismHarness to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.PropertyBasedTesting",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-PropertyBasedTesting env uri)\n  ;; PropertyBasedTesting\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use PropertyBasedTesting to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.FuzzTesting",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-FuzzTesting env uri)\n  ;; FuzzTesting\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use FuzzTesting to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.MutationTesting",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-MutationTesting env uri)\n  ;; MutationTesting\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use MutationTesting to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.DifferentialTesting",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-DifferentialTesting env uri)\n  ;; DifferentialTesting\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use DifferentialTesting to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.CanaryRelease",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-CanaryRelease env uri)\n  ;; CanaryRelease\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use CanaryRelease to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.BlueGreenDeploy",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-BlueGreenDeploy env uri)\n  ;; BlueGreenDeploy\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use BlueGreenDeploy to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.FeatureFlags",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-FeatureFlags env uri)\n  ;; FeatureFlags\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use FeatureFlags to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.TrunkBasedDevelopment",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-TrunkBasedDevelopment env uri)\n  ;; TrunkBasedDevelopment\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use TrunkBasedDevelopment to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.BuildCache",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.CacheEntry",
          "CDT.Core.SemanticKey"
        ],
        "cpos": [
          "CPO.cache_get",
          "CPO.cache_put"
        ],
        "cas": [
          "CA.caching.semantic_memoization"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-BuildCache env uri)\n  ;; BuildCache\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "cache"
      },
      "example_use_cases": [
        "Use BuildCache to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.HermeticBuild",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SnapshotRef",
          "CDT.Core.ContentHash"
        ],
        "cpos": [
          "CPO.snapshot",
          "CPO.semantic_fingerprint"
        ],
        "cas": [
          "CA.normalization.idempotent_canonicalization"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-HermeticBuild env uri)\n  ;; HermeticBuild\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "reproducible"
      },
      "example_use_cases": [
        "Use HermeticBuild to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.FlakyTestQuarantine",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-FlakyTestQuarantine env uri)\n  ;; FlakyTestQuarantine\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use FlakyTestQuarantine to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.SnapshotTesting",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Plan.ExecutionTrace"
        ],
        "cpos": [
          "CPO.golden_master_record",
          "CPO.golden_master_compare"
        ],
        "cas": [
          "CA.machine.golden_master_harness"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-SnapshotTesting env uri)\n  ;; SnapshotTesting\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "goldens"
      },
      "example_use_cases": [
        "Use SnapshotTesting to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.TestPyramid",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-TestPyramid env uri)\n  ;; TestPyramid\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use TestPyramid to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.ShiftLeftSecurity",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.SecurityFinding"
        ],
        "cpos": [
          "CPO.extract",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking"
        ],
        "matrix_views": [
          "ASTView"
        ]
      },
      "omega_skeleton": "(define (ci-ShiftLeftSecurity env uri)\n  ;; ShiftLeftSecurity\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/ops/service"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "security gate"
      },
      "example_use_cases": [
        "Use ShiftLeftSecurity to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.StaticAnalysisGate",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.SecurityFinding"
        ],
        "cpos": [
          "CPO.extract",
          "CPO.check_constraints"
        ],
        "cas": [
          "CA.constraints.specification_checking"
        ],
        "matrix_views": [
          "ASTView"
        ]
      },
      "omega_skeleton": "(define (ci-StaticAnalysisGate env uri)\n  ;; StaticAnalysisGate\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "security gate"
      },
      "example_use_cases": [
        "Use StaticAnalysisGate to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.PolicyGate",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-PolicyGate env uri)\n  ;; PolicyGate\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use PolicyGate to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.SBOMGeneration",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-SBOMGeneration env uri)\n  ;; SBOMGeneration\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/db/users"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use SBOMGeneration to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.DependencyPinning",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Code.CIResult",
          "CDT.Provenance.Receipt"
        ],
        "cpos": [
          "CPO.run_tests",
          "CPO.budget_guard"
        ],
        "cas": [
          "CA.machine.contract_test_harness"
        ],
        "matrix_views": [
          "TimelineView"
        ]
      },
      "omega_skeleton": "(define (ci-DependencyPinning env uri)\n  ;; DependencyPinning\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/app/ui/root"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "ci gate"
      },
      "example_use_cases": [
        "Use DependencyPinning to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.ReproducibleBuilds",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Core.SnapshotRef",
          "CDT.Core.ContentHash"
        ],
        "cpos": [
          "CPO.snapshot",
          "CPO.semantic_fingerprint"
        ],
        "cas": [
          "CA.normalization.idempotent_canonicalization"
        ],
        "matrix_views": [
          "EvidenceView"
        ]
      },
      "omega_skeleton": "(define (ci-ReproducibleBuilds env uri)\n  ;; ReproducibleBuilds\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/project"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "reproducible"
      },
      "example_use_cases": [
        "Use ReproducibleBuilds to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    },
    {
      "family": "ci",
      "pattern_name": "ci.ObservabilityGate",
      "classical_definition": "A CI/testing pattern for enforcing correctness, determinism, and release safety.",
      "cognitive_equivalent": {
        "cdts": [
          "CDT.Ops.LogEvent",
          "CDT.View.TraceView"
        ],
        "cpos": [
          "CPO.query",
          "CPO.summarize"
        ],
        "cas": [
          "CA.normalization.consensus_merge"
        ],
        "matrix_views": [
          "TimelineView",
          "TraceView"
        ]
      },
      "omega_skeleton": "(define (ci-ObservabilityGate env uri)\n  ;; ObservabilityGate\n  (let* ((view (effect matrix.view uri ...))\n         (ans  (effect infer.op ...)))\n    ans))",
      "matrix_usage": {
        "uris": [
          "matrix://realm/docs/contract.pdf"
        ],
        "ports": [
          "EventPort",
          "QueryPort"
        ],
        "distribution": "observability"
      },
      "example_use_cases": [
        "Use ObservabilityGate to build a robust cognitive program skeleton with contracts, receipts, and distributed context."
      ]
    }
  ],
  "worked_examples": [
    {
      "name": "SQL REPL for any file",
      "overview": "Create a RelationalView for an addressable artifact; compile NL->SQL AST under contract; execute deterministically; summarize with evidence and provenance; enforce budgets.",
      "omega_program": "(define (sql-repl env file-uri nl)\n  (budget-guard env (lambda ()\n    (let* ((snap (effect matrix.snapshot file-uri))\n           (rv   (effect matrix.view file-uri :RelationalView :snapshot snap))\n           (sql  (effect infer.op\n                   (contract SQLAST)\n                   (prompt (format \"Translate to SQL under schema: ~a\" (schema rv))\n                           nl)))\n           (rows (compute.sql.exec rv sql))\n           (ev   (compute.evidence.wrap rows :snapshot snap))\n           (ans  (effect infer.op\n                   (contract Answer)\n                   (prompt \"Summarize results; cite evidence row refs\" ev))))\n      (record-receipt env (current-receipt))\n      (emit-provenance env (current-receipt) ans)\n      ans)))",
      "matrix_uris": [
        "matrix://<realm>/files/<any>?view=relational",
        "matrix://<realm>/docs/<pdf>?view=clause",
        "matrix://<realm>/project/<code>?view=ast",
        "matrix://<realm>/logs/<log>?view=timeline"
      ],
      "contracts": [
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Data.SQLAST"
              }
            },
            "required": [
              "_type"
            ]
          }
        },
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Data.QueryResultSet"
              }
            },
            "required": [
              "_type"
            ]
          }
        },
        {
          "kind": "schema",
          "payload": {
            "type": "object",
            "properties": {
              "_type": {
                "const": "CDT.Core.Answer"
              }
            },
            "required": [
              "_type"
            ]
          }
        }
      ],
      "provenance": "Every effect emits Receipt; EvidenceView anchors spans/rows; ProvenanceDAG links (nl prompt -> SQLAST -> rows -> summary) with SnapshotRef.",
      "budgeting": "BudgetGuard caps calls/tokens; compilation uses applicative batching; cache keyed by SemanticKey(schema, nl, env).",
      "notes": "Generalizes by swapping View: ClauseView for PDFs (NL->ClauseQuery), ASTView for code (NL->ASTQuery), TimelineView for logs (NL->event predicates)."
    }
  ],
  "index": {
    "cdts": [
      "CDT.Core.URI",
      "CDT.Core.CapabilitySet",
      "CDT.Core.SnapshotRef",
      "CDT.Core.ContentHash",
      "CDT.Core.SemanticKey",
      "CDT.Core.CacheEntry",
      "CDT.Core.Budget",
      "CDT.Core.Env",
      "CDT.Core.Policy",
      "CDT.Core.SemanticContract",
      "CDT.Core.EnumSpec",
      "CDT.Core.SchemaSpec",
      "CDT.Core.Question",
      "CDT.Core.Answer",
      "CDT.Core.Claim",
      "CDT.Core.Hypothesis",
      "CDT.Core.Decision",
      "CDT.Core.Summary",
      "CDT.Core.TagSet",
      "CDT.Core.RiskAssessment",
      "CDT.Core.Warning",
      "CDT.Core.ErrorReport",
      "CDT.Evidence.SpanRef",
      "CDT.Evidence.RowRef",
      "CDT.Evidence.ClauseRef",
      "CDT.Evidence.Citation",
      "CDT.Evidence.EvidenceSet",
      "CDT.Provenance.Receipt",
      "CDT.Provenance.ProvenanceNode",
      "CDT.Provenance.ProvenanceEdge",
      "CDT.Provenance.ProvenanceDAG",
      "CDT.Provenance.AuditTrail",
      "CDT.Plan.OmegaIR",
      "CDT.Plan.QueryPlan",
      "CDT.Plan.Bytecode",
      "CDT.Plan.ExecutionTrace",
      "CDT.Plan.ToolInvocation",
      "CDT.View.RelationalView",
      "CDT.View.ASTView",
      "CDT.View.ClauseView",
      "CDT.View.TimelineView",
      "CDT.View.DialogueView",
      "CDT.View.EvidenceView",
      "CDT.View.GraphView",
      "CDT.View.StateMachineView",
      "CDT.View.APIView",
      "CDT.View.ConfigView",
      "CDT.View.MetricView",
      "CDT.View.TraceView",
      "CDT.View.UIComponentView",
      "CDT.View.DeviceView",
      "CDT.Science.ExperimentDesign",
      "CDT.Code.FunctionSignature",
      "CDT.Code.ClassModel",
      "CDT.Code.ModulePurpose",
      "CDT.Code.DependencyGraph",
      "CDT.Code.CallGraph",
      "CDT.Code.DataFlowGraph",
      "CDT.Code.SecurityFinding",
      "CDT.Code.RefactoringOpportunity",
      "CDT.Code.TestSpec",
      "CDT.Code.PropertySpec",
      "CDT.Code.BuildGraph",
      "CDT.Code.CIResult",
      "CDT.Code.ChangeSet",
      "CDT.Code.Patch",
      "CDT.Code.ADRView",
      "CDT.Code.Constraint",
      "CDT.Code.ConstraintNetwork",
      "CDT.Code.ConstraintViolation",
      "CDT.Data.TableSchema",
      "CDT.Data.ColumnSchema",
      "CDT.Data.SQLAST",
      "CDT.Data.QueryResultSet",
      "CDT.Data.MetricDefinition",
      "CDT.Data.DimensionalModel",
      "CDT.Data.LineageGraph",
      "CDT.Data.DataQualityReport",
      "CDT.Data.Anomaly",
      "CDT.Data.ForecastNarrative",
      "CDT.Data.SegmentDefinition",
      "CDT.Data.CohortDefinition",
      "CDT.Legal.Clause",
      "CDT.Legal.Obligation",
      "CDT.Legal.Permission",
      "CDT.Legal.Prohibition",
      "CDT.Legal.PolicyDecision",
      "CDT.Legal.RedlinePatch",
      "CDT.Legal.ComplianceRequirement",
      "CDT.Legal.DataRetentionRule",
      "CDT.Legal.AccessControlRule",
      "CDT.Ops.LogEvent",
      "CDT.Ops.IncidentReport",
      "CDT.Ops.RunbookStep",
      "CDT.Ops.SLOViolation",
      "CDT.Ops.Alert",
      "CDT.Ops.RootCauseTree",
      "CDT.UI.UIActionPlan",
      "CDT.IoT.DeviceState",
      "CDT.Medical.PatientSummary"
    ],
    "cpos": [
      "CPO.capabilities",
      "CPO.snapshot",
      "CPO.view",
      "CPO.query",
      "CPO.command",
      "CPO.subscribe_events",
      "CPO.publish_event",
      "CPO.normalize",
      "CPO.cite",
      "CPO.coerce_enum",
      "CPO.coerce_schema",
      "CPO.classify",
      "CPO.extract",
      "CPO.summarize",
      "CPO.questionize",
      "CPO.judge",
      "CPO.rank",
      "CPO.route",
      "CPO.split",
      "CPO.aggregate",
      "CPO.resequence",
      "CPO.plan",
      "CPO.compile",
      "CPO.optimize_ir",
      "CPO.execute_plan",
      "CPO.search",
      "CPO.lookup_ontology",
      "CPO.check_constraints",
      "CPO.propagate_constraints",
      "CPO.generate_alternatives",
      "CPO.select_candidate",
      "CPO.generate_patch",
      "CPO.apply_patch",
      "CPO.rollback_patch",
      "CPO.generate_tests",
      "CPO.run_tests",
      "CPO.golden_master_record",
      "CPO.golden_master_compare",
      "CPO.metamorphic_check",
      "CPO.consensus",
      "CPO.emit_provenance",
      "CPO.minimize_provenance",
      "CPO.record_receipt",
      "CPO.replay_receipt",
      "CPO.semantic_fingerprint",
      "CPO.cache_get",
      "CPO.cache_put",
      "CPO.cache_invalidate",
      "CPO.budget_guard",
      "CPO.redact"
    ],
    "cas": [
      "CA.search.generate_and_test",
      "CA.search.beam_search",
      "CA.search.best_first",
      "CA.search.branch_and_bound",
      "CA.search.amb_backtracking",
      "CA.search.branch_prune",
      "CA.search.topk_sampling",
      "CA.constraints.propagator_fixpoint",
      "CA.constraints.contradiction_detection",
      "CA.constraints.greedy_unsat_core",
      "CA.constraints.specification_checking",
      "CA.constraints.policy_consistency",
      "CA.normalization.meaning_normal_form",
      "CA.normalization.idempotent_canonicalization",
      "CA.normalization.bidirectional_entailment",
      "CA.normalization.self_consistency_voting",
      "CA.normalization.consensus_merge",
      "CA.planning.htn_synthesis",
      "CA.planning.pre_post_guard",
      "CA.planning.saga_compensation",
      "CA.planning.idempotent_command_plan",
      "CA.compilation.nl_to_omega_ir",
      "CA.compilation.omega_ir_typecheck",
      "CA.compilation.cost_based_planner",
      "CA.compilation.applicative_batching",
      "CA.compilation.cse",
      "CA.compilation.dce",
      "CA.compilation.partial_evaluation",
      "CA.compilation.lower_to_bytecode",
      "CA.machine.cognitive_vm_execute",
      "CA.machine.streaming_scatter_gather",
      "CA.machine.backpressure_executor",
      "CA.machine.rate_limited_executor",
      "CA.machine.resequencer_ordering",
      "CA.provenance.provenance_dag_build",
      "CA.provenance.provenance_minimization",
      "CA.provenance.receipt_replay",
      "CA.provenance.evidence_weaving",
      "CA.provenance.citation_synthesis",
      "CA.caching.semantic_memoization",
      "CA.caching.similarity_cache_with_validation",
      "CA.caching.materialized_view_refresh",
      "CA.caching.snapshot_invalidation",
      "CA.concurrency.optimistic_concurrency",
      "CA.concurrency.bulkhead_isolation",
      "CA.concurrency.retry_with_jitter",
      "CA.concurrency.serializer",
      "CA.machine.golden_master_harness",
      "CA.machine.metamorphic_test_harness",
      "CA.machine.contract_test_harness"
    ],
    "patterns": [
      "fp.FunctorMap",
      "fp.ApplicativeBatching",
      "fp.MonadKleisli",
      "fp.FoldReduce",
      "fp.MonoidAggregation",
      "fp.Streams",
      "fp.LazyEvaluation",
      "fp.ParserCombinators",
      "fp.Lenses",
      "fp.Zippers",
      "fp.FixedPoint",
      "fp.Memoization",
      "fp.FreeMonad",
      "fp.EitherError",
      "fp.ValidatedApplicative",
      "fp.Arrows",
      "fp.Continuation",
      "fp.Trampoline",
      "fp.ReaderEnv",
      "fp.WriterLog",
      "fp.StateThread",
      "fp.RefinementTypes",
      "fp.AlgebraicEffects",
      "fp.EffectHandlers",
      "fp.RecursionSchemes",
      "eip.ContentBasedRouter",
      "eip.MessageTranslator",
      "eip.Splitter",
      "eip.Aggregator",
      "eip.Resequencer",
      "eip.ClaimCheck",
      "eip.IdempotentReceiver",
      "eip.Saga",
      "eip.PublishSubscribe",
      "eip.ScatterGather",
      "eip.WireTap",
      "eip.MessageStore",
      "eip.ContentEnricher",
      "eip.MessageFilter",
      "eip.DeadLetterChannel",
      "eip.Retry",
      "eip.CircuitBreaker",
      "eip.CorrelationIdentifier",
      "eip.MessageEndpoint",
      "eip.CompetingConsumers",
      "eip.MessageBridge",
      "eip.Normalizer",
      "eip.RoutingSlip",
      "eip.RecipientList",
      "eip.ChannelAdapter",
      "gof.Strategy",
      "gof.Command",
      "gof.Observer",
      "gof.Mediator",
      "gof.ChainOfResponsibility",
      "gof.Composite",
      "gof.Visitor",
      "gof.Adapter",
      "gof.Facade",
      "gof.Proxy",
      "gof.Decorator",
      "gof.Interpreter",
      "gof.Builder",
      "gof.AbstractFactory",
      "gof.Prototype",
      "gof.TemplateMethod",
      "gof.State",
      "gof.Singleton",
      "gof.Flyweight",
      "gof.Bridge",
      "gof.FactoryMethod",
      "gof.Iterator",
      "gof.Memento",
      "gof.NullObject",
      "gof.ObjectPool",
      "gof.ServiceLocator",
      "gof.Specification",
      "gof.FacadeToLegacy",
      "gof.ProxyCache",
      "gof.DecoratorPolicy",
      "gof.VisitorExtraction",
      "gof.CompositeView",
      "gof.MediatorOrchestrator",
      "gof.ChainRouter",
      "gof.BuilderPlan",
      "ddd.Aggregate",
      "ddd.Repository",
      "ddd.DomainEvent",
      "ddd.BoundedContext",
      "ddd.ContextMap",
      "ddd.AntiCorruptionLayer",
      "ddd.CQRS",
      "ddd.EventSourcing",
      "ddd.ValueObject",
      "ddd.Entity",
      "ddd.Factory",
      "ddd.Service",
      "ddd.Specification",
      "ddd.UbiquitousLanguage",
      "ddd.ApplicationService",
      "ddd.SagaProcessManager",
      "ddd.Outbox",
      "ddd.UnitOfWork",
      "ddd.Invariant",
      "ddd.PolicyAsCode",
      "posa.Layers",
      "posa.PipesAndFilters",
      "posa.Broker",
      "posa.Blackboard",
      "posa.Microkernel",
      "posa.Reactor",
      "posa.HalfSyncHalfAsync",
      "posa.LeaderFollowers",
      "posa.ClientServer",
      "posa.MVC",
      "posa.PAC",
      "posa.PresentationAbstractionControl",
      "posa.ModelViewPresenter",
      "posa.EventDrivenArchitecture",
      "posa.Microservices",
      "posa.ServiceMesh",
      "posa.CQRSArchitecture",
      "posa.HexagonalArchitecture",
      "posa.PortsAndAdapters",
      "posa.SpaceBasedArchitecture",
      "ci.GoldenMaster",
      "ci.ContractTests",
      "ci.MetamorphicTests",
      "ci.ReplayReceipts",
      "ci.DeterminismHarness",
      "ci.PropertyBasedTesting",
      "ci.FuzzTesting",
      "ci.MutationTesting",
      "ci.DifferentialTesting",
      "ci.CanaryRelease",
      "ci.BlueGreenDeploy",
      "ci.FeatureFlags",
      "ci.TrunkBasedDevelopment",
      "ci.BuildCache",
      "ci.HermeticBuild",
      "ci.FlakyTestQuarantine",
      "ci.SnapshotTesting",
      "ci.TestPyramid",
      "ci.ShiftLeftSecurity",
      "ci.StaticAnalysisGate",
      "ci.PolicyGate",
      "ci.SBOMGeneration",
      "ci.DependencyPinning",
      "ci.ReproducibleBuilds",
      "ci.ObservabilityGate"
    ]
  }
}