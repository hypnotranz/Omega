# OmegaRuntime - Clean Public API with Hooks
# Refactor the runtime to have a single public interface that all consumers use
#
# Problem: Runtime logic is duplicated across:
#   - bin/omega-repl.ts (3163 lines)
#   - bin/omega-debugger.ts (1197 lines)
#   - src/server/debugSession.ts
#
# Solution: Extract to src/runtime/ with clean API and event hooks
#
# ═══════════════════════════════════════════════════════════════════════════════
# STRATEGY: PARALLEL REWRITE (not in-place refactor)
# ═══════════════════════════════════════════════════════════════════════════════
#
# This is a significant rewrite. Instead of refactoring in place (risky, hard to
# compare), we use a parallel folder approach:
#
#   1. Copy:     cp -r OmegaLLM OmegaLLM-ref
#                (or use git worktree for OmegaLLM-ref)
#
#   2. Build:    Create clean src/runtime/ in OmegaLLM (working copy)
#                Reference OmegaLLM-ref for existing logic
#
#   3. Rewire:   Gut bin/omega-repl.ts, wire to new runtime
#                Keep OmegaLLM-ref/bin/omega-repl.ts open for reference
#
#   4. Test:     Run same inputs through both, compare outputs
#                OmegaLLM-ref is the behavioral oracle
#
#   5. Delete:   When confident: rm -rf OmegaLLM-ref
#
# Benefits:
#   - Original stays working (no broken intermediate states)
#   - Side-by-side comparison (easy to copy logic, verify behavior)
#   - Clean slate (no temptation to preserve cruft)
#   - Atomic switchover (flip when ready, not before)
#   - Git history stays clean (no "WIP refactor part 17" commits)
#
# ═══════════════════════════════════════════════════════════════════════════════
#
# ═══════════════════════════════════════════════════════════════════════════════
# SOURCE → DESTINATION SUMMARY
# ═══════════════════════════════════════════════════════════════════════════════
#
# WHAT STAYS (src/core/ - THE LANGUAGE IMPLEMENTATION - UNCHANGED):
#   eval/           - CESK machine (machine.ts, machineStep.ts, store.ts, values.ts)
#   pipeline/       - Parser (compileText.ts)
#   effects/        - Effect system (runtimeImpl.ts, opcall.ts)
#   oracle/         - LLM adapters (openai.ts, anthropic.ts, scriptedOracle.ts)
#   opr/            - OPR runtime (runtime.ts, callbacks.ts, kernels/)
#   governance/     - Caps/budgets (profile.ts, caps.ts, budgets.ts)
#   session/        - Session I/O (writer.ts, reader.ts)
#   provenance/     - Provenance graph
#
#   These define what Omega IS. Runtime wraps them, doesn't replace them.
#
# WHAT GETS CREATED (NEW):
#   src/runtime/           - entire new folder (types, events, providers, subsystems)
#
# WHAT GETS GUTTED (3 consumers → thin wrappers):
#   bin/omega-repl.ts      - 3163 → ~300 lines (readline + dispatch)
#   bin/omega-debugger.ts  - 1197 → ~200 lines (TUI + dispatch)
#   src/server/debugSession.ts - thin wrapper, hooks → WebSocket
#
# KEY EXTRACTIONS:
#   REPL step loop, eval    → ExecutionEngine.ts
#   REPL :debug/:step/:run  → DebugSubsystem.ts
#   REPL :break/:breaks     → BreakpointManager.ts
#   REPL :save/:restore     → SnapshotManager.ts
#   REPL :session *         → SessionManager.ts
#   REPL :env/:stack/:frame → StateInspector.ts
#   REPL :back/:history     → HistoryManager.ts
#   REPL :ask/:traces       → LLMIntegration.ts
#   REPL :opr-*             → OprIntegration.ts
#
# FEATURE COUNT (55 features extracted, ~10 stay in CLI):
#   Core Evaluation:      2 →  runtime.eval(), loadFile()
#   Session Persistence:  8 →  runtime.session.*
#   Debug Mode:           7 →  runtime.debug.*
#   Breakpoints:          6 →  runtime.breakpoints.*
#   Snapshots:            4 →  runtime.snapshots.*
#   History/Time Travel:  5 →  runtime.history.*
#   State Inspection:     6 →  runtime.inspect.*
#   LLM/Agentic:          4 →  runtime.llm.*
#   OPR Kernels:          4 →  runtime.opr.*
#   Hooks/Events:         9 →  runtime.on() (NEW - doesn't exist yet)
#
# See 022-omega-runtime.md for COMPLETE TRACEABILITY MATRIX
# ═══════════════════════════════════════════════════════════════════════════════
#
# ═══════════════════════════════════════════════════════════════════════════════
# CODING STANDARDS (MANDATORY)
# ═══════════════════════════════════════════════════════════════════════════════
#
# File Organization:
#   - ONE class or interface per file
#   - Filename MUST match class/interface name in PascalCase
#   - Example: StateProvider interface → StateProvider.ts
#   - Example: MemoryStateProvider class → MemoryStateProvider.ts
#
# Folder Structure:
#   - src/runtime/types/         → All type definitions
#   - src/runtime/events/        → Event emitter and event types
#   - src/runtime/providers/     → Provider interfaces and implementations
#   - src/runtime/subsystems/    → Runtime subsystem classes
#   - src/runtime/internal/      → Internal utilities (not exported)
#
# Index Files:
#   - Every folder MUST have index.ts that re-exports public members
#   - src/runtime/index.ts is THE public API
#
# See 022-omega-runtime.md for complete filesystem structure diagram
# ═══════════════════════════════════════════════════════════════════════════════

features:
  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 0: Core Types & Interfaces
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-types"
    title: "OmegaRuntime Type Definitions"
    job_file: "022-omega-runtime/100-types.md"
    depends_on: []
    description: |
      Define all public types and interfaces for the runtime API:
      - RuntimeConfig, EvalResult, StepResult, RunResult
      - DebugState, TraceEntry, Breakpoint, BreakpointSpec
      - SnapshotInfo, SessionInfo, Checkpoint
      - LLMAdapter, LLMRequest, LLMResponse, LLMTrace
      - KernelInfo, KernelResult, Receipt
      - All event types for hooks
      - All provider interfaces (see 022-providers)
    deliverables:
      - src/runtime/types/index.ts
      - src/runtime/types/RuntimeConfig.ts
      - src/runtime/types/EvalResult.ts
      - src/runtime/types/StepResult.ts
      - src/runtime/types/RunResult.ts
      - src/runtime/types/DebugState.ts
      - src/runtime/types/TraceEntry.ts
      - src/runtime/types/Breakpoint.ts
      - src/runtime/types/SnapshotInfo.ts
      - src/runtime/types/SessionInfo.ts
      - src/runtime/types/HistoryEntry.ts
      - src/runtime/types/ControlInfo.ts
      - src/runtime/types/StackFrame.ts        # Must include FrameDetail
      - src/runtime/types/EnvBindings.ts
      - src/runtime/types/LLMTypes.ts          # Must include AgentResult, LLMTraceSummary, LLMTraceDetail
      - src/runtime/types/OprTypes.ts          # Must include OprLLMAdapter, KernelRegistry
      # AUDIT FIX: Added missing types
      - src/runtime/types/EffectContext.ts
      - src/runtime/types/EffectResult.ts
      - src/runtime/types/MachineSnapshot.ts
      - src/runtime/types/SessionData.ts
      - src/runtime/types/SessionTrace.ts
      - src/runtime/types/Checkpoint.ts
      - src/runtime/types/VerifyResult.ts
      - src/runtime/types/Definition.ts
      # FACT-CHECK FIX: Add type aliases for cleaner API
      - src/runtime/types/aliases.ts         # Effect=OpCall, Receipt=OprReceipt, etc.
      # GAP ANALYSIS: Outcome types from 27-OUTCOMES.md
      - src/runtime/types/Outcome.ts         # Structured return types: ok, proposed, nonconverged, cycle, needs, error
      - src/runtime/types/OutcomeMetadata.ts # Metadata: iterations, tokens, cost, timeMs
      - src/runtime/types/NeedType.ts        # needs-evidence, needs-reframing, etc.
      - src/runtime/types/Proposal.ts        # For transaction mode (deferred)
      # GAP ANALYSIS: Artifact types from 26-ARTIFACTS.md
      - src/runtime/types/Artifact.ts        # ArtifactKey, Artifact, DependencyRecord
      - src/runtime/types/ArtifactStats.ts   # Cache statistics
      # GAP ANALYSIS: Budget types from 25-BUDGET.md
      - src/runtime/types/BudgetReport.ts    # Full budget consumption report
      # AMB types (USER-MANUAL--05, 26)
      - src/runtime/types/ChoicePoint.ts     # Backtracking state
      - src/runtime/types/AmbResult.ts       # Result of amb computation
      - src/runtime/types/BacktrackState.ts  # Backtrack stack state
      # Stream types (USER-MANUAL--07, 23)
      - src/runtime/types/LazyStream.ts      # Stream type definition
      - src/runtime/types/StreamElement.ts   # Element or delay
      # Logic types (USER-MANUAL--27)
      - src/runtime/types/SemanticFact.ts    # Natural language fact
      - src/runtime/types/SemanticRule.ts    # Condition → conclusion rule
      - src/runtime/types/BindingFrame.ts    # Variable bindings
      - src/runtime/types/QueryResult.ts     # Query result with confidence
      # Expert types (29-EXPERTS.md)
      - src/runtime/types/ExpertRole.ts      # Expert role definition
      - src/runtime/types/OutputMode.ts      # REPORT, PLAN, PROGRAM, ANALYSIS
      - src/runtime/types/TaskEnvelope.ts    # Per-call context
      - src/runtime/types/IntentResult.ts    # Compiled intent result
      # Macro types (11-MACROS.md)
      - src/runtime/types/Macro.ts           # Macro definition
      - src/runtime/types/MacroExpansion.ts  # Expansion result
      # Concurrency types (USER-MANUAL--22)
      - src/runtime/types/Fiber.ts           # Fiber handle
      - src/runtime/types/Mutex.ts           # Mutex handle
      - src/runtime/types/Channel.ts         # Channel handle
      - src/runtime/types/Actor.ts           # Actor handle
      # NOTE: Event types live in events/ folder, not here
      # NOTE: Core types are re-exported from src/core/ in index.ts
      # CRITICAL: Use correct core type names (see FACT-CHECK ERRATA in .md):
      #   - Val (not Value)
      #   - OpCall (not Effect)
      #   - Budget (not BudgetTracker)
      #   - OprReceipt (not Receipt)

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 0.5: Pluggable Provider Interfaces
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-providers"
    title: "Pluggable Provider System"
    job_file: "022-omega-runtime/120-providers.md"
    depends_on: ["022-types"]
    description: |
      Define pluggable backend interfaces for all IO/storage.

      NOTE: Providers WRAP existing src/core/ modules, not replace them:
        - FilesystemSessionProvider wraps src/core/session/writer.ts, reader.ts
        - LocalGovernanceProvider wraps src/core/governance/profile.ts
        - MemoryStateProvider wraps src/core/eval/store.ts

      Interfaces:

      StateProvider:
        - createStore(): Store
        - loadStore(id): Promise<Store>
        - saveStore(id, store): Promise<void>
        Implementations: MemoryStateProvider, FilesystemStateProvider

      SessionProvider:
        - list(): Promise<SessionInfo[]>
        - load(name): Promise<SessionData>
        - save(name, data): Promise<void>
        - delete(name): Promise<void>
        Implementations: FilesystemSessionProvider, MockSessionProvider

      SnapshotProvider:
        - list(): Promise<SnapshotInfo[]>
        - save(name, snapshot): Promise<void>
        - load(name): Promise<MachineSnapshot>
        - export(name, path): Promise<void>
        Implementations: MemorySnapshotProvider, FilesystemSnapshotProvider

      ReceiptProvider:
        - store(receipt): Promise<void>
        - list(): Promise<Receipt[]>
        - verify(): Promise<VerifyResult>
        Implementations: InMemoryReceiptProvider, FilesystemReceiptProvider

      TraceProvider:
        - record(entry): void
        - list(): TraceEntry[]
        - dump(path): Promise<void>
        - load(path): Promise<TraceEntry[]>
        Implementations: MemoryTraceProvider, StreamingTraceProvider

      EffectHandlerRegistry:
        - register(op, handler): void
        - get(op): EffectHandler | undefined
        - list(): string[]
        Allows custom effect handling (e.g., mock LLM, custom ops)

      GovernanceProvider:
        - getProfile(): Profile
        - getCaps(): CapSet
        - getBudget(): BudgetTracker
        - checkCap(cap): boolean
        - consumeBudget(amount): boolean
        - hasRemaining(type): boolean  # GAP ANALYSIS: 25-BUDGET.md
        - remaining(type): number | null
        - remainingAll(): Record
        - report(): BudgetReport
        Implementations: LocalGovernanceProvider, RemoteGovernanceProvider

      ArtifactProvider (GAP ANALYSIS: 26-ARTIFACTS.md):
        - get(key): Val | undefined
        - getByExpr(exprKey, fingerprints): Val | undefined
        - put(key, value, metadata): void
        - clear(): void
        - clearByExpr(exprKey): void
        - stats(): ArtifactStats
        - signature(): string
        Implementations: MemoryArtifactProvider, FilesystemArtifactProvider
    deliverables:
      - src/runtime/providers/index.ts
      - src/runtime/providers/StateProvider.ts
      - src/runtime/providers/MemoryStateProvider.ts
      - src/runtime/providers/FilesystemStateProvider.ts
      - src/runtime/providers/SessionProvider.ts
      - src/runtime/providers/FilesystemSessionProvider.ts
      - src/runtime/providers/MockSessionProvider.ts
      - src/runtime/providers/SnapshotProvider.ts
      - src/runtime/providers/MemorySnapshotProvider.ts
      - src/runtime/providers/FilesystemSnapshotProvider.ts
      - src/runtime/providers/ReceiptProvider.ts
      - src/runtime/providers/InMemoryReceiptProvider.ts
      - src/runtime/providers/FilesystemReceiptProvider.ts
      - src/runtime/providers/TraceProvider.ts
      - src/runtime/providers/MemoryTraceProvider.ts
      - src/runtime/providers/StreamingTraceProvider.ts
      - src/runtime/providers/EffectHandlerRegistry.ts
      - src/runtime/providers/EffectHandler.ts
      - src/runtime/providers/GovernanceProvider.ts
      - src/runtime/providers/LocalGovernanceProvider.ts
      - src/runtime/providers/RemoteGovernanceProvider.ts
      # AUDIT FIX: Mock providers for testing (CRITICAL for unit tests)
      - src/runtime/providers/mocks/index.ts
      - src/runtime/providers/mocks/MockStateProvider.ts
      - src/runtime/providers/mocks/MockSnapshotProvider.ts
      - src/runtime/providers/mocks/MockReceiptProvider.ts
      - src/runtime/providers/mocks/MockTraceProvider.ts
      - src/runtime/providers/mocks/MockGovernanceProvider.ts
      - src/runtime/providers/mocks/MockEffectHandlerRegistry.ts
      - src/runtime/providers/mocks/MockEventEmitter.ts
      # GAP ANALYSIS: Artifact providers (26-ARTIFACTS.md)
      - src/runtime/providers/ArtifactProvider.ts
      - src/runtime/providers/MemoryArtifactProvider.ts
      - src/runtime/providers/FilesystemArtifactProvider.ts
      - src/runtime/providers/mocks/MockArtifactProvider.ts
      # Logic providers (USER-MANUAL--27)
      - src/runtime/providers/LogicProvider.ts
      - src/runtime/providers/MemoryLogicProvider.ts
      - src/runtime/providers/mocks/MockLogicProvider.ts
      # Expert providers (29-EXPERTS.md)
      - src/runtime/providers/ExpertProvider.ts
      - src/runtime/providers/DefaultExpertProvider.ts
      - src/runtime/providers/mocks/MockExpertProvider.ts
      # Stream providers (USER-MANUAL--07, 23)
      - src/runtime/providers/StreamProvider.ts
      - src/runtime/providers/MemoryStreamProvider.ts
      - src/runtime/providers/mocks/MockStreamProvider.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 1: Event System (Foundation for Hooks)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-events"
    title: "Event Emitter System"
    job_file: "022-omega-runtime/110-events.md"
    depends_on: ["022-types"]
    description: |
      Typed event emitter for runtime hooks:
      - on(event, handler) -> Unsubscribe
      - emit(event, payload)
      - off(event, handler)
      - once(event, handler)

      Core Events:
        step, before-llm, after-llm, effect, breakpoint-hit,
        error, done, session-checkpoint, opr-receipt

      Subsystem Events:
        condition, fact-asserted, fixpoint-iter, fixpoint-done,
        budget-warning, budget-exceeded, security-event, task-complete,
        amb-choose, amb-fail, amb-solution, stream-force,
        fact-queried, rule-applied, intent-compiled, expert-result,
        macro-expand, deadlock-detected
    deliverables:
      - src/runtime/events/index.ts
      - src/runtime/events/RuntimeEvent.ts
      - src/runtime/events/RuntimeEventEmitter.ts
      # Core events
      - src/runtime/events/StepEvent.ts
      - src/runtime/events/BeforeLLMEvent.ts
      - src/runtime/events/AfterLLMEvent.ts
      - src/runtime/events/EffectEvent.ts
      - src/runtime/events/BreakpointHitEvent.ts
      - src/runtime/events/ErrorEvent.ts
      - src/runtime/events/DoneEvent.ts
      - src/runtime/events/SessionCheckpointEvent.ts
      - src/runtime/events/OprReceiptEvent.ts
      - src/runtime/events/LLMToolCallEvent.ts
      # Conditions/Facts/Fixpoint events
      - src/runtime/events/ConditionEvent.ts
      - src/runtime/events/FactAssertedEvent.ts
      - src/runtime/events/FixpointIterEvent.ts
      - src/runtime/events/FixpointDoneEvent.ts
      # Budget/Security events
      - src/runtime/events/BudgetWarningEvent.ts
      - src/runtime/events/BudgetExceededEvent.ts
      - src/runtime/events/SecurityEvent.ts
      - src/runtime/events/TaskCompleteEvent.ts
      # AMB events (USER-MANUAL--05, 26)
      - src/runtime/events/AmbChooseEvent.ts
      - src/runtime/events/AmbFailEvent.ts
      - src/runtime/events/AmbSolutionEvent.ts
      # Stream events (USER-MANUAL--07, 23)
      - src/runtime/events/StreamForceEvent.ts
      # Logic events (USER-MANUAL--27)
      - src/runtime/events/FactQueriedEvent.ts
      - src/runtime/events/RuleAppliedEvent.ts
      # Expert events (29-EXPERTS.md)
      - src/runtime/events/IntentCompiledEvent.ts
      - src/runtime/events/ExpertResultEvent.ts
      # Macro events (11-MACROS.md)
      - src/runtime/events/MacroExpandEvent.ts
      # Concurrency events
      - src/runtime/events/DeadlockDetectedEvent.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2: Core Runtime Modules
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-execution"
    title: "Execution Engine"
    job_file: "022-omega-runtime/210-execution.md"
    # HARMONY FIX H1: Added 022-macros (macro expansion happens before evaluation)
    depends_on: ["022-types", "022-events", "022-providers", "022-macros"]
    description: |
      Core execution logic extracted from REPL:
      - eval(code) -> Promise<EvalResult>
      - loadFile(path) -> Promise<void>
      - Step loop with event emission
      - Effect handling with hooks
      - Uses StateProvider for store management
      - Uses EffectHandlerRegistry for effect dispatch
      - Uses GovernanceProvider for caps/budget checks
    deliverables:
      - src/runtime/subsystems/ExecutionEngine.ts

  - id: "022-state-coordinator"
    title: "State Coordinator (Mediator)"
    job_file: "022-omega-runtime/220-state-coordinator.md"
    depends_on: ["022-types", "022-events"]
    description: |
      FLAW FIX F2: Internal mediator preventing state conflicts.
      - Tracks active contexts (amb/transaction/fixpoint)
      - Prevents snapshot.restore during AMB search
      - Prevents history.back during fixpoint
      - Coordinates between subsystems safely
    deliverables:
      - src/runtime/internal/StateCoordinator.ts

  - id: "022-budget-llm-adapter"
    title: "Budget-Aware LLM Adapter"
    job_file: "022-omega-runtime/230-budget-llm-adapter.md"
    depends_on: ["022-types", "022-budget"]
    description: |
      FLAW FIX F1: Decorator wrapping LLM adapters with budget checking.
      - Wraps any LLM adapter
      - Checks budget before each call
      - Records consumption after call
      - Fires budget-warning/exceeded events
    deliverables:
      - src/runtime/internal/BudgetAwareLLMAdapter.ts

  - id: "022-debug"
    title: "Debug Subsystem"
    job_file: "022-omega-runtime/350-debug-subsystem.md"
    # AUDIT FIX: DebugSubsystem composes execution + breakpoints + history
    depends_on: ["022-execution", "022-breakpoints", "022-history"]
    description: |
      Debugging functionality as clean API:
      - debug.load(code), debug.step(n), debug.run()
      - debug.stop(), debug.goto(step)
      - debug.getState(), debug.getTrace()
      - Breakpoint checking integrated with step loop
      NOTE: DebugSubsystem composes ExecutionEngine, BreakpointManager, HistoryManager
    deliverables:
      - src/runtime/subsystems/DebugSubsystem.ts

  - id: "022-breakpoints"
    title: "Breakpoint Manager"
    job_file: "022-omega-runtime/300-breakpoints.md"
    depends_on: ["022-types"]
    description: |
      Breakpoint management:
      - breakpoints.add(spec) -> id
      - breakpoints.remove(id)
      - breakpoints.list()
      - breakpoints.toggle(id)
      - Types: step, expr, effect
    deliverables:
      - src/runtime/subsystems/BreakpointManager.ts

  - id: "022-snapshots"
    title: "Snapshot Manager"
    job_file: "022-omega-runtime/330-snapshots.md"
    depends_on: ["022-types", "022-providers"]
    description: |
      State snapshot management:
      - snapshots.save(name)
      - snapshots.restore(name)
      - snapshots.list()
      - snapshots.export(name, path)
      GAP ANALYSIS (USER-MANUAL--09) - Image persistence:
      - snapshots.saveImage(path)   # Full state image to file
      - snapshots.loadImage(path)   # Restore from image file
      Uses SnapshotProvider for pluggable storage
    deliverables:
      - src/runtime/subsystems/SnapshotManager.ts

  - id: "022-session"
    title: "Session Persistence"
    job_file: "022-omega-runtime/340-session.md"
    depends_on: ["022-types", "022-events", "022-providers"]
    description: |
      Session save/load/fork:
      - session.save(name), session.load(name)
      - session.fork(name), session.list()
      - session.goto(checkpoint)
      - session.getTrace(), session.getCheckpoints()
      Uses SessionProvider for pluggable storage
    deliverables:
      - src/runtime/subsystems/SessionManager.ts

  - id: "022-inspect"
    title: "State Inspector"
    job_file: "022-omega-runtime/310-inspector.md"
    depends_on: ["022-types"]
    description: |
      Runtime state inspection:
      - inspect.env(name?)
      - inspect.stack()
      - inspect.frame(n)
      - inspect.control()
      - inspect.defs()
      GAP ANALYSIS (23-FACTS.md) - Facts inspection:
      - inspect.facts()           # Get all facts
      - inspect.factCount()       # Get fact count
      - inspect.hasFact(expr)     # Check if fact exists
      - inspect.factSignature()   # Get facts signature for fixpoint
    deliverables:
      - src/runtime/subsystems/StateInspector.ts

  - id: "022-history"
    title: "History & Time Travel"
    job_file: "022-omega-runtime/320-history.md"
    depends_on: ["022-types", "022-events", "022-providers"]
    description: |
      History tracking and time travel:
      - history.back(n?)
      - history.list(n?)
      - history.setRecording(enabled)
      - history.dump(path)
      - history.replay(path)
      Uses TraceProvider for pluggable trace storage
    deliverables:
      - src/runtime/subsystems/HistoryManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.5: Artifact/Memoization Subsystem (GAP ANALYSIS)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-artifacts"
    title: "Artifact Manager (Content-Addressed Memoization)"
    job_file: "022-omega-runtime/400-artifacts.md"
    depends_on: ["022-types", "022-providers"]
    description: |
      GAP ANALYSIS (26-ARTIFACTS.md):
      Content-addressed memoization for expensive computations.

      - artifacts.get(key)           # Cache lookup
      - artifacts.put(key, value)    # Cache store
      - artifacts.getByExpr(expr)    # Lookup with fingerprint validation
      - artifacts.stats()            # Hit/miss rates
      - artifacts.clear()            # Clear all
      - artifacts.clearByExpr(expr)  # Clear specific

      Uses ArtifactProvider for pluggable storage.
      Tracks dependencies and auto-invalidates on change.
    deliverables:
      - src/runtime/subsystems/ArtifactManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.6: Conditions Subsystem (06-CONDITIONS.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-conditions"
    title: "Conditions Manager (Non-Unwinding Errors)"
    job_file: "022-omega-runtime/500-conditions.md"
    depends_on: ["022-types", "022-events"]
    description: |
      CONDITIONS SYSTEM (06-CONDITIONS.md):
      Non-unwinding error handling with restarts.

      - conditions.signal(type, payload)   # Signal a condition
      - conditions.bind(type, handler)     # Install handler
      - conditions.restart(name, value)    # Invoke restart
      - conditions.getRestarts()           # Get active restarts
      - on('condition', ...)               # Hook

      Exposes CESK condition handling to runtime consumers.
    deliverables:
      - src/runtime/subsystems/ConditionsManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.7: Provenance Subsystem (22-PROVENANCE.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-provenance"
    title: "Provenance Manager (Evidence Tracking)"
    job_file: "022-omega-runtime/600-provenance.md"
    depends_on: ["022-types", "022-providers"]
    description: |
      PROVENANCE SYSTEM (22-PROVENANCE.md):
      Evidence capture, verification, and staleness detection.

      - provenance.capture(ref, opts)      # Capture evidence
      - provenance.verify(id)              # Verify evidence
      - provenance.isStale(id)             # Check staleness
      - provenance.getEvidence(id)         # Get evidence by ID
      - provenance.graph()                 # Get provenance graph
      - provenance.setMode(mode)           # Set epistemic mode
      - provenance.getMode()               # Get epistemic mode

      Wraps src/core/provenance/
    deliverables:
      - src/runtime/subsystems/ProvenanceManager.ts
      - src/runtime/providers/ProvenanceProvider.ts
      - src/runtime/providers/MemoryProvenanceProvider.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.8: Facts Subsystem (23-FACTS.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-facts"
    title: "Facts Manager (Monotone Epistemic State)"
    job_file: "022-omega-runtime/410-facts.md"
    depends_on: ["022-types", "022-events"]
    description: |
      FACTS SYSTEM (23-FACTS.md):
      Access to monotone fact store.

      - facts.all()                        # Get all facts
      - facts.has(expr)                    # Check if fact exists
      - facts.get(expr)                    # Get fact with metadata
      - facts.count()                      # Get count
      - facts.signature()                  # Get signature for fixpoint
      - facts.query(pattern)               # Query facts by pattern
      - on('fact-asserted', ...)           # Hook

      Reads from CESK State fact store.
    deliverables:
      - src/runtime/subsystems/FactsManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.9: Fixpoint Subsystem (24-FIXPOINT.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-fixpoint"
    title: "Fixpoint Manager (Convergence Detection)"
    job_file: "022-omega-runtime/420-fixpoint.md"
    # FLAW FIX F6: Added 022-artifacts (signature mode 'facts+...+artifacts')
    depends_on: ["022-types", "022-events", "022-facts", "022-artifacts"]
    description: |
      FIXPOINT SYSTEM (24-FIXPOINT.md):
      Run computations to convergence.

      - fixpoint.run(body, opts)           # Run fixpoint computation
      - fixpoint.getState()                # Get current fixpoint state
      - fixpoint.signature(mode)           # Compute state signature
      - fixpoint.isInFixpoint()            # Check if in fixpoint
      - on('fixpoint-iter', ...)           # Hook for each iteration
      - on('fixpoint-done', ...)           # Hook for completion

      Returns Outcome (ok/nonconverged/cycle).
    deliverables:
      - src/runtime/subsystems/FixpointManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.10: Transaction Subsystem (27-OUTCOMES.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-transaction"
    title: "Transaction Manager (Staged World Changes)"
    job_file: "022-omega-runtime/510-transaction.md"
    depends_on: ["022-types", "022-events"]
    description: |
      TRANSACTION SYSTEM (27-OUTCOMES.md):
      Staged world changes with propose/commit.

      - transaction.begin()                # Start transaction
      - transaction.propose(proposal)      # Propose change (staged)
      - transaction.getProposals()         # Get pending proposals
      - transaction.commit()               # Commit all proposals
      - transaction.rollback()             # Rollback all proposals
      - transaction.isInTransaction()      # Check if in transaction

      Implements StagedWorld for safe agent operations.
    deliverables:
      - src/runtime/subsystems/TransactionManager.ts
      - src/runtime/internal/StagedWorld.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.11: Security Subsystem (21-SECURITY.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-security"
    title: "Security Manager (Capabilities & Audit)"
    job_file: "022-omega-runtime/610-security.md"
    depends_on: ["022-types", "022-events", "022-providers"]
    description: |
      SECURITY SYSTEM (21-SECURITY.md):
      Capability-based security and audit logging.

      - security.checkCap(cap)             # Check capability
      - security.requireCap(cap)           # Require capability (throws)
      - security.getCaps()                 # Get all capabilities
      - security.validateLLMOutput(out)    # Validate LLM output
      - security.verifySignature(mod,sig)  # Verify module signature
      - security.getAuditLog(opts)         # Get audit log
      - security.getSandboxMode()          # Get sandbox mode
      - security.setSandboxMode(mode)      # Set sandbox mode
      - on('security-event', ...)          # Hook

      Wraps src/core/governance/caps.ts
    deliverables:
      - src/runtime/subsystems/SecurityManager.ts
      - src/runtime/providers/SecurityProvider.ts
      - src/runtime/providers/LocalSecurityProvider.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.12: Budget Subsystem (25-BUDGET.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-budget"
    title: "Budget Manager (Resource Tracking)"
    job_file: "022-omega-runtime/620-budget.md"
    depends_on: ["022-types", "022-events", "022-providers"]
    description: |
      BUDGET SYSTEM (25-BUDGET.md):
      Token/cost/time/iteration tracking.

      - budget.remaining(type)             # Get remaining budget
      - budget.hasRemaining(type)          # Check if has budget
      - budget.consume(type, amount)       # Consume budget
      - budget.report()                    # Full budget report
      - on('budget-warning', ...)          # Hook at 80% consumed
      - on('budget-exceeded', ...)         # Hook when exceeded

      Wraps src/core/governance/budgets.ts
    deliverables:
      - src/runtime/subsystems/BudgetManager.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.13: Protocol Subsystem (08-PROTOCOL.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-protocol"
    title: "Protocol Server (nREPL-style Interface)"
    job_file: "022-omega-runtime/710-protocol.md"
    depends_on: ["022-types", "022-execution"]
    description: |
      PROTOCOL SERVER (08-PROTOCOL.md):
      nREPL-style client-server protocol.

      - protocol.handle(request)           # Handle protocol request
      - protocol.use(middleware)           # Add middleware
      - protocol.listen(opts)              # Start listening
      - protocol.close()                   # Stop server

      Supports transports: stdio, websocket, http
      Standard ops: eval, info, complete, interrupt
      Time-travel ops: snapshot, restore, navigate, fork
    deliverables:
      - src/runtime/subsystems/ProtocolServer.ts
      - src/runtime/protocol/index.ts
      - src/runtime/protocol/Middleware.ts
      - src/runtime/protocol/operations/eval.ts
      - src/runtime/protocol/operations/info.ts
      - src/runtime/protocol/operations/complete.ts
      - src/runtime/protocol/operations/interrupt.ts
      - src/runtime/protocol/operations/snapshot.ts
      - src/runtime/protocol/operations/restore.ts
      - src/runtime/protocol/transports/StdioTransport.ts
      - src/runtime/protocol/transports/WebSocketTransport.ts
      - src/runtime/protocol/transports/HttpTransport.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.14: Concurrency Subsystem (12-CONCURRENCY.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-concurrency"
    title: "Concurrency Manager (Async & Actors)"
    job_file: "022-omega-runtime/700-concurrency.md"
    depends_on: ["022-types", "022-events"]
    description: |
      CONCURRENCY SYSTEM (12-CONCURRENCY.md, USER-MANUAL--22):
      Async operations, actors, channels, fibers, and synchronization.

      Fiber primitives:
      - concurrency.fiberSpawn(thunk)      # fiber.spawn effect
      - concurrency.fiberJoin(fiber)       # fiber.join effect
      - concurrency.fiberSelect(fibers)    # fiber.select - first to complete

      Parallel patterns:
      - concurrency.parallelMap(f, items)  # parallel-map
      - concurrency.parallelFilter(p, items) # parallel-filter
      - concurrency.parallelDo(...thunks)  # Run all in parallel

      Synchronization:
      - concurrency.makeMutex()            # Create mutex
      - concurrency.mutexAcquire(mutex)    # mutex.acquire
      - concurrency.mutexRelease(mutex)    # mutex.release
      - concurrency.mutexTryAcquire(mutex, timeout) # With timeout
      - concurrency.makeSerializer()       # Serializer pattern
      - concurrency.makeSingleflight()     # Deduplication pattern

      Actor model:
      - concurrency.spawn(behavior, state) # Spawn actor
      - concurrency.send(actor, message)   # Send message
      - concurrency.ask(actor, message)    # Request-response

      Channels:
      - concurrency.chan()                 # Create channel
      - concurrency.chanSend(ch, val)      # Send to channel
      - concurrency.chanRecv(ch)           # Receive from channel

      Control:
      - concurrency.awaitAll(promises)     # Wait for all
      - concurrency.awaitAny(promises)     # Wait for first
      - concurrency.withTimeout(ms, p)     # Timeout wrapper
      - concurrency.cancel(taskId)         # Cancel task
      - concurrency.voting(thunk, n)       # Multi-shot voting/consensus

      Hooks:
      - on('task-complete', ...)           # Hook
      - on('deadlock-detected', ...)       # Hook for deadlock
    deliverables:
      - src/runtime/subsystems/ConcurrencyManager.ts
      - src/runtime/internal/Actor.ts
      - src/runtime/internal/Channel.ts
      - src/runtime/internal/Fiber.ts
      - src/runtime/internal/Mutex.ts
      - src/runtime/internal/Serializer.ts
      - src/runtime/internal/Singleflight.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.15: AMB/Backtracking Subsystem (USER-MANUAL--05, 26)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-amb"
    title: "AMB Manager (Nondeterministic Search)"
    job_file: "022-omega-runtime/900-amb.md"
    # FLAW FIX F6: Added execution (evaluate thunks), llm (directedAmb), providers (snapshots)
    depends_on: ["022-types", "022-events", "022-providers", "022-execution", "022-llm"]
    description: |
      AMB SYSTEM (USER-MANUAL--05, USER-MANUAL--26):
      Nondeterministic choice with automatic backtracking.

      Core primitives:
      - amb.choose(alternatives)           # amb.choose effect
      - amb.fail(reason)                   # amb.fail effect - trigger backtrack
      - amb.require(condition)             # Constraint - fails if false

      Search control:
      - amb.allSolutions(thunk)            # Collect ALL satisfying assignments
      - amb.firstSolution(thunk)           # Get first solution
      - amb.directedAmb(prompt, constraint) # LLM-guided candidate generation

      State management:
      - amb.getChoicePoint()               # Current choice point
      - amb.getBacktrackStack()            # Full backtrack stack
      - amb.resetSearch()                  # Clear backtrack state

      Hooks:
      - on('amb-choose', ...)              # Hook when choice made
      - on('amb-fail', ...)                # Hook when backtracking
      - on('amb-solution', ...)            # Hook when solution found

      Semantic constraint satisfaction with LLM predicates.
    deliverables:
      - src/runtime/subsystems/AmbManager.ts
      - src/runtime/internal/BacktrackStack.ts
      - src/runtime/internal/ChoicePoint.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.16: Lazy Streams Subsystem (USER-MANUAL--07, 23)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-streams"
    title: "Streams Manager (Lazy Evaluation)"
    job_file: "022-omega-runtime/910-streams.md"
    # HARMONY FIX H1: Added 022-execution (lazy thunks execute in evaluation context)
    depends_on: ["022-types", "022-events", "022-execution"]
    description: |
      STREAMS SYSTEM (USER-MANUAL--07, USER-MANUAL--23):
      Lazy streams for on-demand computation.

      # HARMONY FIX H4: Simplified API names (namespace provides context)

      Stream construction:
      - streams.fromList(list)             # list->stream
      - streams.cons(head, tailThunk)      # cons-stream (lazy)
      - streams.empty()                    # the-empty-stream

      Stream access:
      - streams.car(s)                     # First element (forced)
      - streams.cdr(s)                     # Rest (lazy)
      - streams.null(s)                    # Check if empty
      - streams.toList(s, n)               # Force n elements

      Stream operations:
      - streams.map(f, s)                  # Lazy map
      - streams.filter(p, s)               # Lazy filter
      - streams.take(s, n)                 # Take first n
      - streams.flatMap(f, s)              # Flat map

      Infinite streams:
      - streams.iterate(f, seed)           # Infinite iteration
      - streams.repeat(value)              # Infinite repetition
      - streams.cycle(list)                # Cycle through list

      Hooks:
      - on('stream-force', ...)            # Hook when element forced

      Enables semantic computation on demand - LLM calls only when needed.
    deliverables:
      - src/runtime/subsystems/StreamsManager.ts
      - src/runtime/internal/LazyStream.ts
      - src/runtime/internal/StreamForcer.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.17: Logic Programming Subsystem (USER-MANUAL--27)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-logic"
    title: "Logic Manager (Semantic Facts & Queries)"
    job_file: "022-omega-runtime/920-logic.md"
    # HARMONY FIX H1: Added 022-llm (semantic queries use LLM for inference)
    depends_on: ["022-types", "022-events", "022-facts", "022-llm"]
    description: |
      LOGIC SYSTEM (USER-MANUAL--27):
      Logic programming with semantic facts and queries.

      Semantic database:
      - logic.assertFact(fact)             # Assert natural language fact
      - logic.addRule(condition, conclusion) # Add semantic rule
      - logic.getFacts()                   # Get all facts

      Querying:
      - logic.query(question)              # Query the database
      - logic.prove(goal)                  # Backward chaining proof
      - logic.closedWorldQuery(q)          # Closed world assumption

      Semantic unification:
      - logic.unify(pattern, text)         # Semantic pattern matching
      - logic.extendFrame(pattern, text, frame) # Extend binding frame

      Compound queries:
      - logic.and(q1, q2)                  # Semantic AND
      - logic.or(q1, q2)                   # Semantic OR
      - logic.not(q)                       # Negation as failure

      Inference vs retrieval:
      - logic.retrieve(term)               # Find matching facts
      - logic.infer(question)              # Derive new information

      Hooks:
      - on('fact-queried', ...)            # Hook when query executed
      - on('rule-applied', ...)            # Hook when rule used

      LLM-powered logic programming over meaning, not symbols.
    deliverables:
      - src/runtime/subsystems/LogicManager.ts
      - src/runtime/internal/SemanticDatabase.ts
      - src/runtime/internal/SemanticUnifier.ts
      - src/runtime/internal/BindingFrame.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.18: Expert System Subsystem (29-EXPERTS.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-experts"
    title: "Expert Manager (Intent Compilation)"
    job_file: "022-omega-runtime/820-experts.md"
    depends_on: ["022-types", "022-events", "022-llm"]
    description: |
      EXPERT SYSTEM (29-EXPERTS.md):
      Three-layer architecture for intent compilation.

      Three layers:
      - Layer A: Tool Contract (stable primitives)
      - Layer B: Role Overlay (domain expertise)
      - Layer C: Task Envelope (per-call context)

      Expert roles:
      - experts.registerRole(role)         # Register expert role
      - experts.getRole(id)                # Get role by ID
      - experts.listRoles()                # List available roles

      Intent compilation:
      - experts.compileIntent(text, role, mode) # Natural language → Lisp
      - experts.validateOutput(expr, mode) # Validate output structure

      Output modes:
      - REPORT: Structured findings report
      - PLAN: Step-by-step execution plan
      - PROGRAM: Executable Lisp code
      - ANALYSIS: Reasoning without actions

      Parallel execution:
      - experts.runParallel(roles, task, aggregation) # Multiple experts
      - experts.batch(intents, role)       # Batch multiple intents

      Hooks:
      - on('intent-compiled', ...)         # Hook when intent compiled
      - on('expert-result', ...)           # Hook when expert returns

      Bridge from natural language to executable code.
    deliverables:
      - src/runtime/subsystems/ExpertManager.ts
      - src/runtime/internal/ToolContract.ts
      - src/runtime/internal/RoleOverlay.ts
      - src/runtime/internal/TaskEnvelope.ts
      - src/runtime/types/ExpertRole.ts
      - src/runtime/types/OutputMode.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 2.19: Macro System Subsystem (11-MACROS.md)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-macros"
    title: "Macro Manager (Compile-Time Transformations)"
    job_file: "022-omega-runtime/200-macros.md"
    depends_on: ["022-types"]
    description: |
      MACRO SYSTEM (11-MACROS.md):
      Compile-time code transformations.

      Macro definition:
      - macros.define(name, params, body)  # defmacro
      - macros.isMacro(name)               # Check if macro
      - macros.getMacro(name)              # Get macro definition

      Expansion:
      - macros.expand1(expr)               # macroexpand-1
      - macros.expandAll(expr)             # macroexpand (recursive)

      Hygiene:
      - macros.gensym(prefix)              # Generate unique symbol

      Quasiquote support:
      - macros.quasiquote(template)        # ` processing
      - macros.unquote(expr)               # , processing
      - macros.splice(expr)                # ,@ processing

      Hooks:
      - on('macro-expand', ...)            # Hook on expansion

      Supports both unhygienic (defmacro) and hygienic (syntax-rules).
    deliverables:
      - src/runtime/subsystems/MacroManager.ts
      - src/runtime/internal/MacroExpander.ts
      - src/runtime/internal/Quasiquoter.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 3: LLM & OPR Integration
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-llm"
    title: "LLM Integration"
    job_file: "022-omega-runtime/800-llm-integration.md"
    depends_on: ["022-execution", "022-events"]
    description: |
      LLM/Agent functionality:
      - llm.configure(adapter)
      - llm.ask(question) -> Promise<AgentResult>
      - llm.getTraces()
      - llm.getTrace(id)
      Tool-calling agent loop with hooks
    deliverables:
      - src/runtime/subsystems/LLMIntegration.ts

  - id: "022-opr"
    title: "OPR Integration"
    job_file: "022-omega-runtime/810-opr-integration.md"
    depends_on: ["022-execution", "022-events", "022-providers"]
    description: |
      OPR kernel integration:
      - opr.list()
      - opr.run(kernel, program) -> Promise<KernelResult>
      - opr.getReceipts()
      - opr.verify()
      Uses ReceiptProvider for pluggable receipt storage
      Wraps existing OPR runtime
    deliverables:
      - src/runtime/subsystems/OprIntegration.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 4: Main Runtime Class
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-runtime"
    title: "OmegaRuntime Main Class"
    job_file: "022-omega-runtime/1000-runtime-assembly.md"
    depends_on:
      # Core infrastructure
      - "022-providers"
      - "022-execution"
      - "022-state-coordinator"
      - "022-budget-llm-adapter"
      # Debugging & inspection
      - "022-debug"
      - "022-breakpoints"
      - "022-snapshots"
      - "022-session"
      - "022-inspect"
      - "022-history"
      # Data & memoization
      - "022-artifacts"
      - "022-facts"
      # Control flow
      - "022-conditions"
      - "022-fixpoint"
      - "022-transaction"
      # Security & governance
      - "022-provenance"
      - "022-security"
      - "022-budget"
      # Communication
      - "022-protocol"
      - "022-concurrency"
      # LLM integration
      - "022-llm"
      - "022-opr"
      # NEW: Semantic computation (USER-MANUAL features)
      - "022-amb"       # AMB/Backtracking (USER-MANUAL--05, 26)
      - "022-streams"   # Lazy Streams (USER-MANUAL--07, 23)
      - "022-logic"     # Logic Programming (USER-MANUAL--27)
      - "022-experts"   # Expert System (29-EXPERTS.md)
      - "022-macros"    # Macro System (11-MACROS.md)
    description: |
      Main runtime class that composes ALL subsystems (24 total):
      - Facade pattern - single entry point
      - All subsystems as properties
      - Event delegation
      - Factory function: createRuntime(config)
      - RuntimeConfig accepts all providers
      - Default providers for zero-config usage

      Subsystem categories:
      - Core: execution, providers
      - Debugging: debug, breakpoints, snapshots, session, inspect, history
      - Data: artifacts, facts
      - Control: conditions, fixpoint, transaction
      - Governance: provenance, security, budget
      - Communication: protocol, concurrency
      - LLM: llm, opr, experts
      - Semantic: amb, streams, logic, macros
    deliverables:
      - src/runtime/index.ts
      - src/runtime/OmegaRuntime.ts
      - src/runtime/subsystems/index.ts
      - src/runtime/internal/index.ts
      - src/runtime/internal/StateCloner.ts
      - src/runtime/internal/ControlFormatter.ts
      - src/runtime/internal/FrameFormatter.ts
      - src/runtime/internal/ValueSerializer.ts
      - src/runtime/internal/IdGenerator.ts
      # FLAW FIX F2: StateCoordinator mediates Amb/Snapshot/History state conflicts
      - src/runtime/internal/StateCoordinator.ts
      # FLAW FIX F1: Budget-aware LLM adapter wrapper
      - src/runtime/internal/BudgetAwareLLMAdapter.ts

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 5: Consumer Refactoring
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-repl-refactor"
    title: "Refactor REPL to Use Runtime"
    job_file: "022-omega-runtime/1100-repl-refactor.md"
    depends_on: ["022-runtime"]
    description: |
      Refactor omega-repl.ts to use OmegaRuntime:
      - Remove all duplicated runtime logic
      - Keep only: readline loop, command parsing, output formatting
      - Target: ~300 lines (down from 3163)
    deliverables:
      - bin/omega-repl.ts (refactored)

  - id: "022-server-refactor"
    title: "Refactor DebugServer to Use Runtime"
    job_file: "022-omega-runtime/1110-server-refactor.md"
    depends_on: ["022-runtime"]
    description: |
      Refactor debugServer + debugSession to use OmegaRuntime:
      - DebugSession becomes thin wrapper
      - Subscribe to runtime hooks for WebSocket events
      - Remove duplicated logic
    deliverables:
      - src/server/debugSession.ts (refactored)
      - src/server/debugServer.ts (refactored)

  - id: "022-debugger-refactor"
    title: "Refactor Standalone Debugger"
    job_file: "022-omega-runtime/1120-debugger-refactor.md"
    depends_on: ["022-runtime"]
    description: |
      Refactor omega-debugger.ts to use OmegaRuntime:
      - Use runtime.debug.* methods
      - Subscribe to hooks for display
    deliverables:
      - bin/omega-debugger.ts (refactored)

  # ═══════════════════════════════════════════════════════════════════════════
  # Layer 6: Tests & Documentation
  # ═══════════════════════════════════════════════════════════════════════════

  - id: "022-unit-tests"
    title: "Runtime Unit Tests"
    job_file: "022-omega-runtime/1210-unit-tests.md"
    depends_on: ["022-runtime", "022-mocks"]
    description: |
      Comprehensive unit tests for all OmegaRuntime subsystems.
      Uses mock providers for isolated testing.
      See 1210-unit-tests.md for complete test structure.

  - id: "022-integration-tests"
    title: "Integration Tests"
    job_file: "022-omega-runtime/1220-integration-tests.md"
    depends_on: ["022-runtime", "022-mocks"]
    description: |
      Integration tests verifying subsystems work together:
      - Cross-subsystem interaction tests
      - Event propagation tests
      - State coordination tests
      See 1220-integration-tests.md for complete test matrix.

  - id: "022-e2e-tests"
    title: "E2E CLI Tests"
    job_file: "022-omega-runtime/1230-e2e-tests.md"
    depends_on: ["022-repl-refactor", "022-server-refactor", "022-debugger-refactor"]
    description: |
      End-to-end tests for refactored CLI tools:
      - REPL E2E tests
      - Debugger E2E tests
      - Server E2E tests
      See 1230-e2e-tests.md for test structure.

  - id: "022-demos"
    title: "Demo Coverage & Auto-Discovery Infrastructure"
    job_file: "022-omega-runtime/1240-demos.md"
    depends_on: ["022-runtime", "022-mocks"]
    description: |
      Demo infrastructure for every runtime feature:
      - Each demo in its own folder with setup, run, test
      - Auto-discovery of demos for batch testing
      - LLM mock/live mode controlled by environment variable
      - Record mode to capture LLM responses for replay

      DEMO STRUCTURE:
        demos/<demo-name>/
        ├── setup.ts           # Provider config, runtime setup
        ├── run.ts             # Main demo script (standalone)
        ├── run.test.ts        # Vitest test wrapper
        ├── expected-output.json
        ├── mock-responses.json (optional)
        └── README.md

      RUN COMMANDS:
        npm run demo <name>           # Interactive demo
        npm run test:demo <name>      # Test single demo
        npm run test:demos            # All demos (mock mode)
        OMEGA_LLM_MODE=live npm run test:demos  # Real LLM
    deliverables:
      # ─── DEMO INFRASTRUCTURE ───
      - demos/__test_runner__.ts      # Auto-discovery runner
      - demos/vitest.demos.config.ts  # Demo test config
      - demos/DemoRunner.ts           # Demo execution helper
      - demos/index.ts                # Demo discovery exports
      # ─── CORE DEMOS ───
      - demos/01-basic-eval/setup.ts
      - demos/01-basic-eval/run.ts
      - demos/01-basic-eval/run.test.ts
      - demos/01-basic-eval/expected-output.json
      - demos/01-basic-eval/README.md
      # ─── DEBUG DEMOS ───
      - demos/02-debug-step-through/setup.ts
      - demos/02-debug-step-through/run.ts
      - demos/02-debug-step-through/run.test.ts
      - demos/02-debug-step-through/expected-output.json
      - demos/02-debug-step-through/README.md
      - demos/03-breakpoints/setup.ts
      - demos/03-breakpoints/run.ts
      - demos/03-breakpoints/run.test.ts
      - demos/03-breakpoints/expected-output.json
      - demos/03-breakpoints/README.md
      # ─── STATE DEMOS ───
      - demos/04-snapshots/setup.ts
      - demos/04-snapshots/run.ts
      - demos/04-snapshots/run.test.ts
      - demos/04-snapshots/expected-output.json
      - demos/04-snapshots/README.md
      - demos/05-session-persistence/setup.ts
      - demos/05-session-persistence/run.ts
      - demos/05-session-persistence/run.test.ts
      - demos/05-session-persistence/expected-output.json
      - demos/05-session-persistence/README.md
      - demos/06-time-travel/setup.ts
      - demos/06-time-travel/run.ts
      - demos/06-time-travel/run.test.ts
      - demos/06-time-travel/expected-output.json
      - demos/06-time-travel/README.md
      # ─── LLM DEMOS ───
      - demos/07-llm-ask/setup.ts
      - demos/07-llm-ask/run.ts
      - demos/07-llm-ask/run.test.ts
      - demos/07-llm-ask/expected-output.json
      - demos/07-llm-ask/mock-responses.json
      - demos/07-llm-ask/README.md
      - demos/08-opr-kernels/setup.ts
      - demos/08-opr-kernels/run.ts
      - demos/08-opr-kernels/run.test.ts
      - demos/08-opr-kernels/expected-output.json
      - demos/08-opr-kernels/README.md
      # ─── HOOK/EVENT DEMOS ───
      - demos/09-hooks-events/setup.ts
      - demos/09-hooks-events/run.ts
      - demos/09-hooks-events/run.test.ts
      - demos/09-hooks-events/expected-output.json
      - demos/09-hooks-events/README.md
      # ─── PROVIDER DEMOS ───
      - demos/10-custom-providers/setup.ts
      - demos/10-custom-providers/run.ts
      - demos/10-custom-providers/run.test.ts
      - demos/10-custom-providers/expected-output.json
      - demos/10-custom-providers/README.md
      # ─── PROTOCOL DEMOS ───
      - demos/11-protocol-server/setup.ts
      - demos/11-protocol-server/run.ts
      - demos/11-protocol-server/run.test.ts
      - demos/11-protocol-server/expected-output.json
      - demos/11-protocol-server/README.md
      # ─── SEMANTIC DEMOS ───
      - demos/12-amb-backtracking/setup.ts
      - demos/12-amb-backtracking/run.ts
      - demos/12-amb-backtracking/run.test.ts
      - demos/12-amb-backtracking/expected-output.json
      - demos/12-amb-backtracking/mock-responses.json
      - demos/12-amb-backtracking/README.md
      - demos/13-lazy-streams/setup.ts
      - demos/13-lazy-streams/run.ts
      - demos/13-lazy-streams/run.test.ts
      - demos/13-lazy-streams/expected-output.json
      - demos/13-lazy-streams/README.md
      - demos/14-logic-programming/setup.ts
      - demos/14-logic-programming/run.ts
      - demos/14-logic-programming/run.test.ts
      - demos/14-logic-programming/expected-output.json
      - demos/14-logic-programming/mock-responses.json
      - demos/14-logic-programming/README.md
      - demos/15-expert-compilation/setup.ts
      - demos/15-expert-compilation/run.ts
      - demos/15-expert-compilation/run.test.ts
      - demos/15-expert-compilation/expected-output.json
      - demos/15-expert-compilation/mock-responses.json
      - demos/15-expert-compilation/README.md
      - demos/16-macro-expansion/setup.ts
      - demos/16-macro-expansion/run.ts
      - demos/16-macro-expansion/run.test.ts
      - demos/16-macro-expansion/expected-output.json
      - demos/16-macro-expansion/README.md
      # ─── CONTROL DEMOS ───
      - demos/17-conditions-restarts/setup.ts
      - demos/17-conditions-restarts/run.ts
      - demos/17-conditions-restarts/run.test.ts
      - demos/17-conditions-restarts/expected-output.json
      - demos/17-conditions-restarts/README.md
      - demos/18-fixpoint-convergence/setup.ts
      - demos/18-fixpoint-convergence/run.ts
      - demos/18-fixpoint-convergence/run.test.ts
      - demos/18-fixpoint-convergence/expected-output.json
      - demos/18-fixpoint-convergence/mock-responses.json
      - demos/18-fixpoint-convergence/README.md
      - demos/19-transactions/setup.ts
      - demos/19-transactions/run.ts
      - demos/19-transactions/run.test.ts
      - demos/19-transactions/expected-output.json
      - demos/19-transactions/README.md
      # ─── GOVERNANCE DEMOS ───
      - demos/20-provenance-tracking/setup.ts
      - demos/20-provenance-tracking/run.ts
      - demos/20-provenance-tracking/run.test.ts
      - demos/20-provenance-tracking/expected-output.json
      - demos/20-provenance-tracking/README.md
      - demos/21-budget-limits/setup.ts
      - demos/21-budget-limits/run.ts
      - demos/21-budget-limits/run.test.ts
      - demos/21-budget-limits/expected-output.json
      - demos/21-budget-limits/README.md
      - demos/22-security-caps/setup.ts
      - demos/22-security-caps/run.ts
      - demos/22-security-caps/run.test.ts
      - demos/22-security-caps/expected-output.json
      - demos/22-security-caps/README.md
      # ─── CONCURRENCY DEMOS ───
      - demos/23-concurrent-fibers/setup.ts
      - demos/23-concurrent-fibers/run.ts
      - demos/23-concurrent-fibers/run.test.ts
      - demos/23-concurrent-fibers/expected-output.json
      - demos/23-concurrent-fibers/README.md
      # ─── DATA DEMOS ───
      - demos/24-artifacts-memoization/setup.ts
      - demos/24-artifacts-memoization/run.ts
      - demos/24-artifacts-memoization/run.test.ts
      - demos/24-artifacts-memoization/expected-output.json
      - demos/24-artifacts-memoization/README.md

  - id: "022-mocks"
    title: "LLM Mock Infrastructure"
    job_file: "022-omega-runtime/1200-mocks.md"
    depends_on: ["022-providers"]
    description: |
      Mockable LLM infrastructure for testing without real API calls:

      FEATURES:
      - MockLLMAdapter with configurable responses
      - Pattern matching for dynamic responses
      - Recording mode to capture real LLM responses
      - Replay mode using recorded responses
      - Environment variable control (OMEGA_LLM_MODE)

      USAGE:
        // Direct mock
        const mock = new MockLLMAdapter({
          responses: [{ match: /classify/, response: '(list "a")' }]
        });

        // From recorded file
        const mock = MockLLMAdapter.fromScript('responses.json');

        // Recording mode
        const mock = MockLLMAdapter.recording();
        // ... run with real LLM ...
        mock.saveRecording('responses.json');
    deliverables:
      # ─── MOCK LLM ADAPTER ───
      - src/runtime/providers/mocks/MockLLMAdapter.ts
      - src/runtime/providers/mocks/LLMResponseMatcher.ts
      - src/runtime/providers/mocks/LLMRecorder.ts
      - src/runtime/providers/mocks/LLMReplayer.ts
      # ─── MOCK ORACLE (integrates with existing) ───
      - src/runtime/providers/mocks/MockOracleAdapter.ts
      # ─── RECORDING/REPLAY INFRASTRUCTURE ───
      - src/runtime/testing/RecordingSession.ts
      - src/runtime/testing/ReplaySession.ts
      - src/runtime/testing/index.ts
      # ─── ENVIRONMENT CONFIG ───
      - src/runtime/config/envConfig.ts
      - src/runtime/config/index.ts
      # ─── TESTS FOR MOCK INFRASTRUCTURE ───
      - tests/runtime/mocks/MockLLMAdapter.test.ts
      - tests/runtime/mocks/LLMRecorder.test.ts
      - tests/runtime/mocks/LLMReplayer.test.ts

  - id: "022-docs"
    title: "Runtime API Documentation"
    job_file: "022-omega-runtime/1300-documentation.md"
    depends_on: ["022-runtime"]
    description: |
      Documentation for the public API:
      - API reference
      - Hook event catalog
      - Migration guide from old REPL commands
    deliverables:
      - docs/runtime-api.md
