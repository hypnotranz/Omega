# 900: AMB Manager

## Status: COMPLETE ✅
- **Completed**: 2026-01-29
- **Location**: OmegaLLM-3/src/runtime/subsystems/AmbManager.ts (471 lines)

## Purpose
Implements nondeterministic choice (amb) with backtracking for exploring multiple solution paths.

## Dependencies
- 100-types.md ✅
- 110-events.md ✅
- 120-providers.md ✅
- 210-execution.md ✅
- 220-state-coordinator.md ✅
- 800-llm-integration.md ✅

## Source References
- SICP Chapter 4.3 (Nondeterministic Computing)
- docs/USER-MANUAL--05--AMB-And-The-Art-Of-Nondeterministic-Choice.md
- docs/USER-MANUAL--26--AMB-As-An-Inference-Engine.md
- ARCHITECTURE/32-10-AMB-SYNTAX.md

---

## Deliverables

```
src/runtime/subsystems/
├── AmbManager.ts            # Main AMB manager
└── amb/
    ├── ChoicePoint.ts       # Choice point tracking
    ├── BacktrackStack.ts    # Backtracking state
    └── AmbSearch.ts         # Search strategies
```

---

## Key Types

```typescript
export interface ChoicePoint {
  id: string;
  alternatives: Thunk[];      // Remaining alternatives
  currentIndex: number;       // Which alternative we're on
  checkpointId: string;       // StateCoordinator checkpoint
  env: Environment;           // Captured environment
  timestamp: number;
}

export type SearchStrategy = 'depth-first' | 'breadth-first' | 'random';

export interface AmbState {
  isSearching: boolean;
  depth: number;              // Nesting depth
  choicePoints: ChoicePoint[];
  currentPath: number[];      // Choice indices taken
  exploredPaths: number;
  totalAlternatives: number;
}

export interface AmbResult<T> {
  found: boolean;
  value?: T;
  path?: number[];
  exploredPaths: number;
  backtracks: number;
}

type Thunk = () => Val;
```

---

## Key Interface

```typescript
export interface AmbManager {
  // ─── Core Operations ───

  /**
   * Nondeterministic choice.
   * Returns one of the alternatives, establishing a choice point.
   */
  amb(alternatives: Val[]): Val;

  /**
   * Lazy amb with thunks.
   */
  ambLazy(alternatives: Thunk[]): Val;

  /**
   * Fail current path, backtrack to previous choice point.
   */
  fail(): never;

  /**
   * Require condition, fail if false.
   */
  require(condition: boolean): void;

  // ─── Search Control ───

  /**
   * Run body in AMB search context.
   * Returns first successful result or throws.
   */
  search<T>(body: () => T): AmbResult<T>;

  /**
   * Find all solutions.
   */
  searchAll<T>(body: () => T, limit?: number): T[];

  /**
   * Set search strategy.
   */
  setStrategy(strategy: SearchStrategy): void;

  /**
   * Reset search (clear all choice points).
   */
  resetSearch(): void;

  // ─── State Queries ───

  /**
   * Get current AMB state.
   */
  getState(): AmbState;

  /**
   * Is an AMB search in progress?
   */
  isSearching(): boolean;

  /**
   * Get current search depth.
   */
  getDepth(): number;

  /**
   * Get path of choices taken.
   */
  getCurrentPath(): number[];
}
```

---

## Core Implementation

```typescript
class AmbManagerImpl implements AmbManager {
  private choicePoints: ChoicePoint[] = [];
  private strategy: SearchStrategy = 'depth-first';

  amb(alternatives: Val[]): Val {
    if (alternatives.length === 0) {
      this.fail();
    }

    // Check with coordinator
    const error = this.coordinator.canStartAmb();
    if (error) {
      throw new StateConflictError('start AMB', error,
        this.coordinator.getContextDepth());
    }

    // Create checkpoint for backtracking
    const checkpointId = this.coordinator.checkpoint('amb');

    // Create choice point
    const choicePoint: ChoicePoint = {
      id: generateId(),
      alternatives: alternatives.map(a => () => a),
      currentIndex: 0,
      checkpointId,
      env: this.getCurrentEnv(),
      timestamp: Date.now()
    };

    this.choicePoints.push(choicePoint);
    this.coordinator.enterAmb(checkpointId);

    // Emit event
    this.emitter.emit('amb-choice', {
      choicePointId: choicePoint.id,
      alternativeCount: alternatives.length,
      depth: this.choicePoints.length
    });

    // Return first alternative
    return alternatives[0];
  }

  fail(): never {
    if (this.choicePoints.length === 0) {
      throw new AmbExhaustedError('No more alternatives');
    }

    // Get current choice point
    const choicePoint = this.choicePoints[this.choicePoints.length - 1];
    choicePoint.currentIndex++;

    if (choicePoint.currentIndex >= choicePoint.alternatives.length) {
      // Exhausted this choice point
      this.choicePoints.pop();
      this.coordinator.exitAmb();
      this.coordinator.discard(choicePoint.checkpointId);

      // Emit event
      this.emitter.emit('amb-exhausted', {
        choicePointId: choicePoint.id
      });

      // Try to fail up the stack
      this.fail();
    }

    // Backtrack
    const state = this.coordinator.restore(choicePoint.checkpointId, 'amb');

    // Notify coordinator (for transaction rollback)
    this.coordinator.notifyAmbBacktrack(choicePoint.checkpointId);

    // Emit event
    this.emitter.emit('amb-backtrack', {
      choicePointId: choicePoint.id,
      alternativeIndex: choicePoint.currentIndex,
      checkpointId: choicePoint.checkpointId
    });

    // This throw will be caught by the evaluator which will:
    // 1. Restore the CESK state
    // 2. Re-evaluate with next alternative
    throw new BacktrackSignal(choicePoint, state);
  }

  require(condition: boolean): void {
    if (!condition) {
      this.fail();
    }
  }
}
```

---

## Search Implementation

```typescript
search<T>(body: () => T): AmbResult<T> {
  const startTime = Date.now();
  let exploredPaths = 0;
  let backtracks = 0;

  try {
    const value = body();

    // Success!
    return {
      found: true,
      value,
      path: this.getCurrentPath(),
      exploredPaths,
      backtracks
    };
  } catch (e) {
    if (e instanceof BacktrackSignal) {
      backtracks++;
      exploredPaths++;
      // Evaluator handles the backtrack
      throw e;
    }
    if (e instanceof AmbExhaustedError) {
      return {
        found: false,
        exploredPaths,
        backtracks
      };
    }
    throw e;
  }
}

searchAll<T>(body: () => T, limit?: number): T[] {
  const results: T[] = [];

  while (true) {
    try {
      const result = this.search(body);
      if (result.found) {
        results.push(result.value!);
        if (limit && results.length >= limit) break;
        // Force backtrack to find next
        this.fail();
      } else {
        break; // Exhausted
      }
    } catch (e) {
      if (e instanceof AmbExhaustedError) break;
      throw e;
    }
  }

  return results;
}
```

---

## Lisp Interface

```lisp
;; Basic amb
(let ((x (amb '(1 2 3))))
  (require (even? x))
  x)
; => 2

;; Multiple amb
(let ((x (amb '(1 2 3)))
      (y (amb '(1 2 3))))
  (require (= (+ x y) 4))
  (list x y))
; => (1 3) ;; First solution

;; Find all solutions
(amb-search-all
  (let ((x (amb '(1 2 3)))
        (y (amb '(1 2 3))))
    (require (= (+ x y) 4))
    (list x y)))
; => ((1 3) (2 2) (3 1))

;; Reset search
(amb-reset)

;; With LLM alternatives
(amb (list
       (lambda () (effect infer.op "approach 1"))
       (lambda () (effect infer.op "approach 2"))))
```

---

## Integration with StateCoordinator

The AMB manager works with StateCoordinator to:
1. Create checkpoints before choices
2. Restore state on backtrack
3. Prevent conflicting operations during search
4. Trigger transaction rollbacks

See [220-state-coordinator.md](220-state-coordinator.md) for conflict rules.

---

## Test Requirements

### Unit Tests: `tests/runtime/subsystems/AmbManager.test.ts`
- [ ] amb() returns first alternative
- [ ] fail() backtracks to previous choice
- [ ] require() fails when false
- [ ] Nested amb works correctly
- [ ] search() returns first solution
- [ ] searchAll() finds all solutions
- [ ] searchAll() respects limit
- [ ] AmbExhaustedError when no solutions
- [ ] Checkpoint created for each choice point
- [ ] State restored on backtrack

### Integration Tests
- [ ] AMB with transaction rollback
- [ ] AMB with LLM calls
- [ ] StateCoordinator blocking works
- [ ] Large search spaces complete
- [ ] Events track search progress

---

## Acceptance Criteria
1. Nondeterministic choice works correctly
2. Backtracking restores exact state
3. All solutions can be found
4. StateCoordinator integration prevents conflicts
5. Transaction rollback on backtrack works
6. Performance: reasonable for typical search spaces
